{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"DBMS - Structured Query Language (SQL) This is an online textbook for the course Database Management Systems (DBMS) associated with Structured Query Language (SQL). Note to students : This book is meant to be used as a reference. You may find content that has not been covered in the video lectures. Likewise, there may be some content that is present in the lectures which is not covered here. Additional content appearing in this book will not be considered for grading. In summary, please refer to chapters that you feel are relevant for the course. But you are under no obligation to read the entire book cover to cover. Interested students are always welcome to read the entire thing! INDEX S.No CONTENT SUMMARY AND IMPLEMENTATIONS 1 Data Definition Language (DDL) Open 2 Data Manipulation Language (DML) Open 3 Transaction Control Language (TCL) Open 4 Data Control Language (DCL) Open 5 Procedural SQL (PLSQL) Open 6 Connecting with python (Using psycopg2 module) Open LEARNING STRATEGY FOR DBMS","title":"DBMS - Structured Query Language (SQL)"},{"location":"#dbms-structured-query-language-sql","text":"This is an online textbook for the course Database Management Systems (DBMS) associated with Structured Query Language (SQL). Note to students : This book is meant to be used as a reference. You may find content that has not been covered in the video lectures. Likewise, there may be some content that is present in the lectures which is not covered here. Additional content appearing in this book will not be considered for grading. In summary, please refer to chapters that you feel are relevant for the course. But you are under no obligation to read the entire book cover to cover. Interested students are always welcome to read the entire thing!","title":"DBMS - Structured Query Language (SQL)"},{"location":"#index","text":"S.No CONTENT SUMMARY AND IMPLEMENTATIONS 1 Data Definition Language (DDL) Open 2 Data Manipulation Language (DML) Open 3 Transaction Control Language (TCL) Open 4 Data Control Language (DCL) Open 5 Procedural SQL (PLSQL) Open 6 Connecting with python (Using psycopg2 module) Open","title":"INDEX"},{"location":"#learning-strategy-for-dbms","text":"","title":"LEARNING STRATEGY FOR DBMS"},{"location":"PLSQL/","text":"Home Procedural SQL Procedural SQL includes the imperative programming style associated with computational steps in the function calls. SQL functions: parameterized views that generalize the regular notion of views by allowing parameters. Supports loops, if-then-else and assignment statements. Creating a procedure: Syntax : Here is the syntax of creating a function. create function <function_name> (<argument_name> <domain_of_argument>) returns <return_type_domain> begin declare <variable_name> <domain_of_variable> ..... //some query to store the result into the variable. ..... return <variable_name> end create is a ddl command for creating. function is the keyword used to signify that a function is being created. It takes an argument specified with its domain type. returns keyword is used to signify the domain returned by the function. begin is used to begin the body of the procedure. return keyword before the end is used to actually return the result of the function. end keyword is used to end the procedure. Define a function that, given the name of a department, returns the count of the number of instructors in that department: create function dept_count(dept_name varchar(20)) returns integer language 'plpgsql' as $BODY$ #variable_conflict use_column declare d_count integer; begin select count(*) into d_count from instructor where instructor.dept_name = dept_name; return d_count; end $BODY$ dept_count is the name of the function that is created. The function takes dept_name of type varchar(20) as the argument and returns an integer. language 'plpgsql' is used to convey that we are using Procedural SQL in Postregsql. as $$ specifies the block within which the actual procedure definition starts. #variable_conflict use_column is a special plpgsql command that prevents a clash between the parameter names being used in the function and the argument names actually passed in it. In the begin-end clause, a variable named d_count of type integer is declared. The select query is used to store the count of the instructors in the dept_name taken as the argument, into the variable d_count. into keyword is used for that. The variable d_count containing the stored result is returned by the function. Using the function in the following query: Find the department names and budget of all departments with more than 12 instructors: select dept_name, budget from department where dept_count(dept_name) > 12 Here dept_count(dept_name) function is called in the where clause. The function returns the number of instructors in the department dept_name and that number is compared with 12 in the where clause. If it is greater than 12, the dept_name and budget corresponding to that row is extracted, otherwise not. Note : Here dept_name is the same as the name of the parameter in the defined function above. Postgresql raises an error if the clash is not resolved. That is the reason why #variable_conflict use_column is used. Deleting a Procedure: SYNTAX drop function <function_name> (<argument list>) The above procedure can be deleted by: drop function dept_count(dept_name varchar(20)) Table-Valued Functions: Return a table as a result of the function. create or replace function instructor_of(dept_name char(20)) returns table( id varchar(5), name varchar(20), dept_name varchar(20), salary numeric(8,2)) language plpgsql as $$ begin return query select instructor.id, instructor.name, instructor.dept_name, instructor.salary from instructor where instructor.dept_name = instructor_of.dept_name ; end; $$; A select query is returned that in turn returns a table as a result. NOTE: The columns in the select query should match with the columns in the expected resulting table. select * from instructor_of('Music') Returns a table consisting of all the tuples where the department name is 'Music'. Loops: While loop syntax while <boolean expression> do <sequence of statements> end while The sequence of statements will run until the boolean expression is true. EXAMPLE: do $$ declare add integer := 10; begin while add > 0 loop raise notice 'Out addition count %',add; add := add-1; end loop; end$$; OUTPUT: NOTICE: Out addition count 10 NOTICE: Out addition count 9 NOTICE: Out addition count 8 NOTICE: Out addition count 7 NOTICE: Out addition count 6 NOTICE: Out addition count 5 NOTICE: Out addition count 4 NOTICE: Out addition count 3 NOTICE: Out addition count 2 NOTICE: Out addition count 1 DO Query returned successfully in 137 msec. Repeat loop syntax repeat sequence of statements until boolean expression end repeat; The sequence of statements will run until the boolean expression is false. For loop syntax [ <<label>> ] for loop_count in [ reverse ] from.. to [ by step ] loop statements end loop [ label ]; EXAMPLE: do $$ begin for cnt in reverse 10..1 loop raise notice 'cnt: %', cnt; end loop; end; $$ OUTPUT: NOTICE: cnt: 10 NOTICE: cnt: 9 NOTICE: cnt: 8 NOTICE: cnt: 7 NOTICE: cnt: 6 NOTICE: cnt: 5 NOTICE: cnt: 4 NOTICE: cnt: 3 NOTICE: cnt: 2 NOTICE: cnt: 1 DO Query returned successfully in 91 msec. if-then-else and case statements: if-then-else syntax if <boolean expression> then sequence of statements; elseif <boolean expression> then sequence of statements; else sequence of statements; end if where * elseif is an optional clause. * else is a default clause. Case statement syntax case <variable> when <value1> then sequence of statements; when <value2> then sequence of statements; else sequence of statements; end case where * if variable takes the particular value in the when then clause, the corresponding sequence of statements are executed. Exceptions declare out_of_classroom_seats condition declare exit handler for out_of_classroom_seats begin ... signal out of classroom seats ... end The handler here is exit \u2013 causes enclosing begin . . . end to be terminate and exit. Triggers a set of actions that are performed in response to an insert, update, or delete operation on a specified table. Creating a trigger: Syntax : CREATE TRIGGER <triggername> {BEFORE | AFTER |INSTEAD OF} { INSERt | DELETE | UPDATE | TRUNCATE } ON <tablename> [FOR [EACH] { ROW | STATEMENT }] EXECUTE PROCEDURE trigger_function A trigger for some event (insert/delete/update/trincate) named \\ is created on the table named \\ either for each row or for each statement which makes it a row level or a statement level trigger accordingly, which is then executed as a procedure either before the calling of a function / after the function call or instead of the function call. Before triggers Run before an update, or insert. Values that are being updated or inserted can be modified before the database is actually modified. After triggers Run after an update, insert, or delete. Row level triggers Executed whenever a row is affected by the event on which the trigger is defined. Example: Let Employee be a table with 100 rows. Suppose an update statement is executed to increase the salary of each employee by 10%. Any row level update trigger configured on the table Employee will affect all the 100 rows in the table during this update. Statement level triggers Perform a single action for all rows affected by a statement, instead of executing a separate action for each affected row. Uses referencing old table or referencing new table to refer to temporary tables called transition tables containing the affected rows. Dropping a trigger Syntax : DROP TRIGGER <triggername> ON <table_name> { CASCADE | RESTRICT } deleted the trigger. Using triggers Values of attributes before and after an update can be referenced: referencing old row as : for deletes and updates referencing new row as : for inserts and updates NOTE : Triggers on update can be restricted to specific attributes For example, after update of _grade_ on _takes_ SYNTAX : CREATE FUNCTION trigger_function() RETURNS TRIGGER LANGUAGE PLPGSQL AS $$ BEGIN -- trigger logic END; $$ A Case Study Consider a student result management system in DBMS in which the teachers need to insert the entries of students into a table that contains the following columns: * Roll_no = Primary key * Name * marks1 corresponding to DDL marks * marks2 corresponding to DML marks * marks3 corresponding to TCL marks * total_marks = sum total of all the marks * average_marks = average of the marks scored in the 3 subjects. Given below is the SQL code for the table: create table student( roll_no int primary key, name varchar(20), marks1 int, marks2 int, marks3 int, total_marks int, average_marks float) Now, in order to automate the process of calculating the average marks of all the subjects and store them in the average_marks column, each time a teacher inserts a new tuple into the relation, the database administrator decided to create a trigger that will accelerate the calculation of total_marks and average_marks before each insert . create or replace function calc_total_avg() returns trigger as $$ declare total int; avgerage float; begin total =new.marks1 + new.marks2 + new.marks3; new.total_marks=total; new.average_marks=total/3; return new; end; $$ language plpgsql; A function called calc_total_avg() is created if it doesn't exist already / replaced if it exists already, and returns a trigger which does the required task. 2 variables: total of type integer and avgerage of type float are created. The begin-end block contains the working of the function after declaring the variables. new marks the new entry that has been entered by the user. The attributes: marks1, marks2 and marks3 are accessed, added and stored in total. total is then stored in the total_marks column of the new entry. total is then divided by the total number of subjects (3 in this case) to give the average marks and the result is stored in the average_marks column. Creating the trigger: create trigger calc_total_avg_insert before insert on student for each row execute procedure calc_total_avg(); A trigger called calc_total_avg_insert is created to execute the procedure called calc_total_avg() before the event of insertion on the student relation. It is a row level trigger as we need to perform the operation for each row. ~ for each row . The teachers now start adding entries into the table. The values just contain the roll number, name of the students, marks1, marks2 and marks3. The calculation of total_marks and average_narks is triggered before each insert automatically. insert into student values(1,'Subendu',90,98,94) Let us check the entries in the table: select * from student The result contains the values added as well as the total_marks and average_marks calculated along with them.","title":"PLSQL"},{"location":"PLSQL/#procedural-sql","text":"Procedural SQL includes the imperative programming style associated with computational steps in the function calls. SQL functions: parameterized views that generalize the regular notion of views by allowing parameters. Supports loops, if-then-else and assignment statements.","title":"Procedural SQL"},{"location":"PLSQL/#creating-a-procedure","text":"Syntax : Here is the syntax of creating a function. create function <function_name> (<argument_name> <domain_of_argument>) returns <return_type_domain> begin declare <variable_name> <domain_of_variable> ..... //some query to store the result into the variable. ..... return <variable_name> end create is a ddl command for creating. function is the keyword used to signify that a function is being created. It takes an argument specified with its domain type. returns keyword is used to signify the domain returned by the function. begin is used to begin the body of the procedure. return keyword before the end is used to actually return the result of the function. end keyword is used to end the procedure. Define a function that, given the name of a department, returns the count of the number of instructors in that department: create function dept_count(dept_name varchar(20)) returns integer language 'plpgsql' as $BODY$ #variable_conflict use_column declare d_count integer; begin select count(*) into d_count from instructor where instructor.dept_name = dept_name; return d_count; end $BODY$ dept_count is the name of the function that is created. The function takes dept_name of type varchar(20) as the argument and returns an integer. language 'plpgsql' is used to convey that we are using Procedural SQL in Postregsql. as $$ specifies the block within which the actual procedure definition starts. #variable_conflict use_column is a special plpgsql command that prevents a clash between the parameter names being used in the function and the argument names actually passed in it. In the begin-end clause, a variable named d_count of type integer is declared. The select query is used to store the count of the instructors in the dept_name taken as the argument, into the variable d_count. into keyword is used for that. The variable d_count containing the stored result is returned by the function. Using the function in the following query: Find the department names and budget of all departments with more than 12 instructors: select dept_name, budget from department where dept_count(dept_name) > 12 Here dept_count(dept_name) function is called in the where clause. The function returns the number of instructors in the department dept_name and that number is compared with 12 in the where clause. If it is greater than 12, the dept_name and budget corresponding to that row is extracted, otherwise not. Note : Here dept_name is the same as the name of the parameter in the defined function above. Postgresql raises an error if the clash is not resolved. That is the reason why #variable_conflict use_column is used.","title":"Creating a procedure:"},{"location":"PLSQL/#deleting-a-procedure","text":"SYNTAX drop function <function_name> (<argument list>) The above procedure can be deleted by: drop function dept_count(dept_name varchar(20))","title":"Deleting a Procedure:"},{"location":"PLSQL/#table-valued-functions","text":"Return a table as a result of the function. create or replace function instructor_of(dept_name char(20)) returns table( id varchar(5), name varchar(20), dept_name varchar(20), salary numeric(8,2)) language plpgsql as $$ begin return query select instructor.id, instructor.name, instructor.dept_name, instructor.salary from instructor where instructor.dept_name = instructor_of.dept_name ; end; $$; A select query is returned that in turn returns a table as a result. NOTE: The columns in the select query should match with the columns in the expected resulting table. select * from instructor_of('Music') Returns a table consisting of all the tuples where the department name is 'Music'.","title":"Table-Valued Functions:"},{"location":"PLSQL/#loops","text":"While loop syntax while <boolean expression> do <sequence of statements> end while The sequence of statements will run until the boolean expression is true. EXAMPLE: do $$ declare add integer := 10; begin while add > 0 loop raise notice 'Out addition count %',add; add := add-1; end loop; end$$; OUTPUT: NOTICE: Out addition count 10 NOTICE: Out addition count 9 NOTICE: Out addition count 8 NOTICE: Out addition count 7 NOTICE: Out addition count 6 NOTICE: Out addition count 5 NOTICE: Out addition count 4 NOTICE: Out addition count 3 NOTICE: Out addition count 2 NOTICE: Out addition count 1 DO Query returned successfully in 137 msec. Repeat loop syntax repeat sequence of statements until boolean expression end repeat; The sequence of statements will run until the boolean expression is false. For loop syntax [ <<label>> ] for loop_count in [ reverse ] from.. to [ by step ] loop statements end loop [ label ]; EXAMPLE: do $$ begin for cnt in reverse 10..1 loop raise notice 'cnt: %', cnt; end loop; end; $$ OUTPUT: NOTICE: cnt: 10 NOTICE: cnt: 9 NOTICE: cnt: 8 NOTICE: cnt: 7 NOTICE: cnt: 6 NOTICE: cnt: 5 NOTICE: cnt: 4 NOTICE: cnt: 3 NOTICE: cnt: 2 NOTICE: cnt: 1 DO Query returned successfully in 91 msec.","title":"Loops:"},{"location":"PLSQL/#if-then-else-and-case-statements","text":"if-then-else syntax if <boolean expression> then sequence of statements; elseif <boolean expression> then sequence of statements; else sequence of statements; end if where * elseif is an optional clause. * else is a default clause. Case statement syntax case <variable> when <value1> then sequence of statements; when <value2> then sequence of statements; else sequence of statements; end case where * if variable takes the particular value in the when then clause, the corresponding sequence of statements are executed.","title":"if-then-else and case statements:"},{"location":"PLSQL/#exceptions","text":"declare out_of_classroom_seats condition declare exit handler for out_of_classroom_seats begin ... signal out of classroom seats ... end The handler here is exit \u2013 causes enclosing begin . . . end to be terminate and exit.","title":"Exceptions"},{"location":"PLSQL/#triggers","text":"a set of actions that are performed in response to an insert, update, or delete operation on a specified table.","title":"Triggers"},{"location":"PLSQL/#creating-a-trigger","text":"Syntax : CREATE TRIGGER <triggername> {BEFORE | AFTER |INSTEAD OF} { INSERt | DELETE | UPDATE | TRUNCATE } ON <tablename> [FOR [EACH] { ROW | STATEMENT }] EXECUTE PROCEDURE trigger_function A trigger for some event (insert/delete/update/trincate) named \\ is created on the table named \\ either for each row or for each statement which makes it a row level or a statement level trigger accordingly, which is then executed as a procedure either before the calling of a function / after the function call or instead of the function call.","title":"Creating a trigger:"},{"location":"PLSQL/#before-triggers","text":"Run before an update, or insert. Values that are being updated or inserted can be modified before the database is actually modified.","title":"Before triggers"},{"location":"PLSQL/#after-triggers","text":"Run after an update, insert, or delete.","title":"After triggers"},{"location":"PLSQL/#row-level-triggers","text":"Executed whenever a row is affected by the event on which the trigger is defined. Example: Let Employee be a table with 100 rows. Suppose an update statement is executed to increase the salary of each employee by 10%. Any row level update trigger configured on the table Employee will affect all the 100 rows in the table during this update.","title":"Row level triggers"},{"location":"PLSQL/#statement-level-triggers","text":"Perform a single action for all rows affected by a statement, instead of executing a separate action for each affected row. Uses referencing old table or referencing new table to refer to temporary tables called transition tables containing the affected rows.","title":"Statement level triggers"},{"location":"PLSQL/#dropping-a-trigger","text":"Syntax : DROP TRIGGER <triggername> ON <table_name> { CASCADE | RESTRICT } deleted the trigger.","title":"Dropping a trigger"},{"location":"PLSQL/#using-triggers","text":"Values of attributes before and after an update can be referenced: referencing old row as : for deletes and updates referencing new row as : for inserts and updates NOTE : Triggers on update can be restricted to specific attributes For example, after update of _grade_ on _takes_ SYNTAX : CREATE FUNCTION trigger_function() RETURNS TRIGGER LANGUAGE PLPGSQL AS $$ BEGIN -- trigger logic END; $$","title":"Using triggers"},{"location":"PLSQL/#a-case-study","text":"Consider a student result management system in DBMS in which the teachers need to insert the entries of students into a table that contains the following columns: * Roll_no = Primary key * Name * marks1 corresponding to DDL marks * marks2 corresponding to DML marks * marks3 corresponding to TCL marks * total_marks = sum total of all the marks * average_marks = average of the marks scored in the 3 subjects. Given below is the SQL code for the table: create table student( roll_no int primary key, name varchar(20), marks1 int, marks2 int, marks3 int, total_marks int, average_marks float) Now, in order to automate the process of calculating the average marks of all the subjects and store them in the average_marks column, each time a teacher inserts a new tuple into the relation, the database administrator decided to create a trigger that will accelerate the calculation of total_marks and average_marks before each insert . create or replace function calc_total_avg() returns trigger as $$ declare total int; avgerage float; begin total =new.marks1 + new.marks2 + new.marks3; new.total_marks=total; new.average_marks=total/3; return new; end; $$ language plpgsql; A function called calc_total_avg() is created if it doesn't exist already / replaced if it exists already, and returns a trigger which does the required task. 2 variables: total of type integer and avgerage of type float are created. The begin-end block contains the working of the function after declaring the variables. new marks the new entry that has been entered by the user. The attributes: marks1, marks2 and marks3 are accessed, added and stored in total. total is then stored in the total_marks column of the new entry. total is then divided by the total number of subjects (3 in this case) to give the average marks and the result is stored in the average_marks column. Creating the trigger: create trigger calc_total_avg_insert before insert on student for each row execute procedure calc_total_avg(); A trigger called calc_total_avg_insert is created to execute the procedure called calc_total_avg() before the event of insertion on the student relation. It is a row level trigger as we need to perform the operation for each row. ~ for each row . The teachers now start adding entries into the table. The values just contain the roll number, name of the students, marks1, marks2 and marks3. The calculation of total_marks and average_narks is triggered before each insert automatically. insert into student values(1,'Subendu',90,98,94) Let us check the entries in the table: select * from student The result contains the values added as well as the total_marks and average_marks calculated along with them.","title":"A Case Study"},{"location":"dcl/","text":"Home Data Control Language: Deals with the security of the database. Maintains concurrent access. Grants and revokes various permissions to access the database. Forms of authorization on parts of the database: Read - allows reading, but not modification of data Insert - allows insertion of new data, but not modification of existing data Update - allows modification, but not deletion of data Delete - allows deletion of data Forms of authorization to modify the database schema: Index - allows creation and deletion of indices Resources - allows creation of new relations Alteration - allows addition or deletion of attributes in a relation Drop - allows deletion of relations Grant used to confer authorisation SYNTAX grant <privilege list> on <relation name or view name> to <user list> where: privilege list includes: select: allows read access to relation. insert: the ability to insert tuples. update: the ability to update using the SQL update statement. delete: the ability to delete tuples. all privileges: used as a short form for all the allowable privileges. Example: grant select on instructor to U1,U2,U3 The above query grants the select privilege on the instructor table to the users U1, U2 and U3 . user list includes: a user-id public - which allows all valid users the privilege granted A role - groups users under a name so that privileges can be added powerfully to a group directly rather than granting one by one to each user. Creating a role: create role instructor1; grant select on takes to instructor1 The above query creates a role named instructor1 and grants the select privilege of the table takes to the users falling under the role of instructor1 . create role teaching_assistant; grant teaching_assistant to instructor1; The above query creates a role named teaching_assistant and grants the privileges available to the role to the users falling under the role of instructor1 . This means instructor1 inherits the permissions from teaching_assistant . A chain of roles can be constructed likewish in an organisational hierarchy. NOTE : Granting a privilege on a view does not imply granting any privileges on the underlying relations. The grantor of the privilege must already hold the privilege on the specified item (or be the database administrator). Revoke Used to revoke authorization. SYNTAX revoke <privilege list> on <relation name or view name> from <user list> Example: revoke select on branch from U1,U2,U3 The above query revokes the select privilege on the instructor table for the users U1, U2 and U3 . revoke select on takes from instructor1; NOTE : If the same privilege was granted twice to the same user by different grantees, the user may retain the privilege after the revocation. All privileges that depend on the privilege being revoked are also revoked. Authorisation on Views: create role geo_staff; create view geo_instructor as (select * from instructor where dept_name = 'Geology'); grant select on geo_instructor to geo_staff The above query creates a view named geo_instructor that contains all the tuples from the relation instructor where department name is Geology. It then grants the select privilege of the view created to the role named geo_staff . Other features: References privilege to create foreign key create role Mariano; grant references (dept_name) on department to Mariano; This is required to grant the referential integrity constraint. Transfer of privileges: grant select on department to instructor1 with grant option Here the keywords with grant option signify that the select privilege has been given to instructor1 and he will further be able to grant it to any other user or role. revoke select on department from instructor1, geo_staff cascade Cascade signifies that select privilege will be revoked along with all other privileges which depend on it. oke select on department from instructor1, geo_staff restrict Restrict signifies that select privilege will only be revoked it there are no other privileges depending on it.","title":"Dcl"},{"location":"dcl/#data-control-language","text":"Deals with the security of the database. Maintains concurrent access. Grants and revokes various permissions to access the database. Forms of authorization on parts of the database: Read - allows reading, but not modification of data Insert - allows insertion of new data, but not modification of existing data Update - allows modification, but not deletion of data Delete - allows deletion of data Forms of authorization to modify the database schema: Index - allows creation and deletion of indices Resources - allows creation of new relations Alteration - allows addition or deletion of attributes in a relation Drop - allows deletion of relations","title":"Data Control Language:"},{"location":"dcl/#grant","text":"used to confer authorisation SYNTAX grant <privilege list> on <relation name or view name> to <user list> where: privilege list includes: select: allows read access to relation. insert: the ability to insert tuples. update: the ability to update using the SQL update statement. delete: the ability to delete tuples. all privileges: used as a short form for all the allowable privileges. Example: grant select on instructor to U1,U2,U3 The above query grants the select privilege on the instructor table to the users U1, U2 and U3 . user list includes: a user-id public - which allows all valid users the privilege granted A role - groups users under a name so that privileges can be added powerfully to a group directly rather than granting one by one to each user.","title":"Grant"},{"location":"dcl/#creating-a-role","text":"create role instructor1; grant select on takes to instructor1 The above query creates a role named instructor1 and grants the select privilege of the table takes to the users falling under the role of instructor1 . create role teaching_assistant; grant teaching_assistant to instructor1; The above query creates a role named teaching_assistant and grants the privileges available to the role to the users falling under the role of instructor1 . This means instructor1 inherits the permissions from teaching_assistant . A chain of roles can be constructed likewish in an organisational hierarchy. NOTE : Granting a privilege on a view does not imply granting any privileges on the underlying relations. The grantor of the privilege must already hold the privilege on the specified item (or be the database administrator).","title":"Creating a role:"},{"location":"dcl/#revoke","text":"Used to revoke authorization. SYNTAX revoke <privilege list> on <relation name or view name> from <user list> Example: revoke select on branch from U1,U2,U3 The above query revokes the select privilege on the instructor table for the users U1, U2 and U3 . revoke select on takes from instructor1; NOTE : If the same privilege was granted twice to the same user by different grantees, the user may retain the privilege after the revocation. All privileges that depend on the privilege being revoked are also revoked.","title":"Revoke"},{"location":"dcl/#authorisation-on-views","text":"create role geo_staff; create view geo_instructor as (select * from instructor where dept_name = 'Geology'); grant select on geo_instructor to geo_staff The above query creates a view named geo_instructor that contains all the tuples from the relation instructor where department name is Geology. It then grants the select privilege of the view created to the role named geo_staff .","title":"Authorisation on Views:"},{"location":"dcl/#other-features","text":"References privilege to create foreign key create role Mariano; grant references (dept_name) on department to Mariano; This is required to grant the referential integrity constraint. Transfer of privileges: grant select on department to instructor1 with grant option Here the keywords with grant option signify that the select privilege has been given to instructor1 and he will further be able to grant it to any other user or role. revoke select on department from instructor1, geo_staff cascade Cascade signifies that select privilege will be revoked along with all other privileges which depend on it. oke select on department from instructor1, geo_staff restrict Restrict signifies that select privilege will only be revoked it there are no other privileges depending on it.","title":"Other features:"},{"location":"ddl/","text":"Home DATA DEFINITION LANGUAGE (DDL) Here, we start by creating the University Database schema (given below) used in the recorded lectures to give the essence of the Data Definition Language (DDL) commands in SQL. Schema for University Database DDL consists of: Schema, Domain of attributes: char(n) varchar(n) int smallint numeric(p,d) real , double precision float Integrity Constraints not null primary key foreign key references r (Referential Integrity Constraint) Some more datatypes in SQL: date : Dates, containing a (4 digit) year, month and date. Example: date '2005-7-27' time : Time of day, in hours, minutes and seconds. Example: time '09:00:30' time '09:00:30.75' timestamp : date plus time of day. Example: timestamp '2005-7-27 09:00:30.75' interval : period of time. Example:interval '1' day Subtracting a date/time/timestamp value from another = interval value. Interval values can be added to date/time/timestamp values. SYNTAX for table creation create table r (A1D1, A2D2, . . . , AnDn), (integrity-constraint1), . . . (integrity-constraintk)); where r = relation name. Ai = Name of the i'th attribute. Di = Name of the i'th domain. Let us start creating the University Database. Creating classroom table. create table classroom (building varchar(15), room_number varchar(7), capacity numeric(4,0), primary key (building, room_number) ); The above table has 3 columns: Attribute Domain Integrity Constraint building varchar(15) primary key (composite) room_number varchar(7) primary key (composite) capacity numeric(4,0) - Here, both building and room_number uniquely identify every tuple present in the table classroom. Thus, they form a composite primary key for the classroom table. Primary key is a key that uniquely identifies every tuple present in a relation. They must have unique non null values. Existence of more than one primary key makes it a composite primary key altogether. The domain type of varchar(15) of building means that a user can add any variable length string with a maximum limit of 15 characters. The domain type numeric(4,0) of capacity allows a total of 4 digits to be stored out of which 0 digits should be on the right hand side of the decimal point. Creating table department create table department (dept_name varchar(20), building varchar(15), budget numeric(12,2) check (budget > 0), primary key (dept_name) ); The above table has 3 columns: Attribute Domain Integrity Constraint dept_name varchar(20) primary key building varchar(15) - budget numeric(12,2) check (budget > 0) Here the integrity constraint check (budget > 0) ensures that all the values in the budget column should be greater than 0. Creating table course create table course (course_id varchar(8), title varchar(50), dept_name varchar(20), credits numeric(2,0) check (credits > 0), primary key (course_id), foreign key (dept_name) references department (dept_name) on delete set null ); The above table has 4 columns: Attribute Domain Integrity Constraint course_id varchar(8) primary key title varchar(50) - dept_name varchar(20) foreign key (dept_name) references department (dept_name) on delete set null credits numeric(2,0) check (credits > 0) Here, the attribute dept_name acts as a foreign key that refers to the primary key dept_name of the department table. It is used to link tables in SQL. Foreign key is an attribute in a table that refers to the primary key of another table and describes association between both the relations. Foreign key is associated with a foreign key constraint or Referential Integrity Constraint. It implies an Insert Constraint that specifies that a value cannot be inserted into the referencing table (Table with the foriegn key) if it does not exist in the referenced table (Table with the primary key). It implies a Delete Constraint that specifies that a value cannot be deleted from the referencing table (Table with the foriegn key) if it exists in the referenced table (Table with the primary key). The integrity contraint on delete set null acts on the foreign key dept_name . If the records in the base table department are deleted, the corresponding foreign key records are not deleted, they are instead, updated to NULL . Creating table instructor create table instructor (ID varchar(5), name varchar(20) not null, dept_name varchar(20), salary numeric(8,2) check (salary > 29000), primary key (ID), foreign key (dept_name) references department (dept_name) on delete set null ); The above table has 3 columns: Attribute Domain Integrity Constraint ID varchar(5) primary key name varchar(20) not null dept_name varchar(20) foreign key (dept_name) references department (dept_name) on delete set null Creating table section create table section (course_id varchar(8), sec_id varchar(8), semester varchar(6) check (semester in ('Fall', 'Winter', 'Spring', 'Summer')), year numeric(4,0) check (year > 1701 and year < 2100), building varchar(15), room_number varchar(7), time_slot_id varchar(4), primary key (course_id, sec_id, semester, year), foreign key (course_id) references course (course_id) on delete cascade, foreign key (building, room_number) references classroom (building, room_number) on delete set null ); The above table has 7 columns: Attribute Domain Integrity Constraint course_id varchar(8) primary key (composite), foreign key (course_id) references course (course_id) on delete cascade sec_id varchar(8) primary key (composite) semester varchar(6) check (semester in ('Fall', 'Winter', 'Spring', 'Summer')) year numeric(4,0) check (year > 1701 and year < 2100) building varchar(15) foreign key (building, room_number) references classroom (building, room_number) room_number varchar(7) foreign key (building, room_number) references classroom (building, room_number) time_slot_id varchar(4) - Hear we have 2 foreign keys: course_id - a single foreign key linking the table section with the table course having a single primary key course_id (building, room_number) - a composite foreign key linking the table classroom having a composite primary key (building, room_number) . on delete cascade is a referential integrity constraint that allows the deletion of a value from the base table if the value is existing in the referencing table without the violation of the delete contraint. Similarly the other tables have been created below... Creating table teaches create table teaches (ID varchar(5), course_id varchar(8), sec_id varchar(8), semester varchar(6), year numeric(4,0), primary key (ID, course_id, sec_id, semester, year), foreign key (course_id, sec_id, semester, year) references section (course_id, sec_id, semester, year) on delete cascade, foreign key (ID) references instructor (ID) on delete cascade ); Creating table student create table student (ID varchar(5), name varchar(20) not null, dept_name varchar(20), tot_cred numeric(3,0) check (tot_cred >= 0), primary key (ID), foreign key (dept_name) references department (dept_name) on delete set null ); Creating table takes create table takes (ID varchar(5), course_id varchar(8), sec_id varchar(8), semester varchar(6), year numeric(4,0), grade varchar(2), primary key (ID, course_id, sec_id, semester, year), foreign key (course_id, sec_id, semester, year) references section (course_id, sec_id, semester, year) on delete cascade, foreign key (ID) references student (ID) on delete cascade ); Creating table advisor create table advisor (s_ID varchar(5), i_ID varchar(5), primary key (s_ID), foreign key (i_ID) references instructor (ID) on delete set null, foreign key (s_ID) references student (ID) on delete cascade ); Creating table time_slot create table time_slot (time_slot_id varchar(4), day varchar(1), start_hr numeric(2) check (start_hr >= 0 and start_hr < 24), start_min numeric(2) check (start_min >= 0 and start_min < 60), end_hr numeric(2) check (end_hr >= 0 and end_hr < 24), end_min numeric(2) check (end_min >= 0 and end_min < 60), primary key (time_slot_id, day, start_hr, start_min) ); Creating table prereq create table prereq (course_id varchar(8), prereq_id varchar(8), primary key (course_id, prereq_id), foreign key (course_id) references course (course_id) on delete cascade, foreign key (prereq_id) references course (course_id) ); Let us create a test table r to run the commands to modify the table. create table r (build varchar(15), room varchar(7), capa numeric(4,0), primary key (build, room) ); ALTER command Used to modify already created tables in the database. Adding a column: alter table r add A D where r = name of the relation to be modified. A = Name of the new column to be added. D = Domain name of the new column A. ALTER TABLE r ADD newcol varchar(5) The above command adds a new attribute named newcol of domain type varchar(5) to the table r . Dropping an existing column: SYNTAX alter table r drop A where r = name of the relation A = name of the attribute to be dropped. DROP command To remove an existing table from the database. SYNTAX drop table r where r = name of the existing table to be dropped. If the table r already exists, it will be dropped successfully. DROP TABLE Query returned successfully in 65 msec. But if it does not exist, an error message will be printed out. ERROR: table \"r\" does not exist SQL state: 42P01 Handling the error using 'IF EXISTS' clause: DROP TABLE IF EXISTS r; This will handle the error and raise a notice instead. NOTICE: table \"r\" does not exist, skipping DROP TABLE Query returned successfully in 77 msec. Views: Any relation that is not of the conceptual model but is made visible to a user as a \"virtual relation\". SYNTAX: create view v as <query expression> where query expression is any legal SQL expression. View definition is not the same as creating a new relation by evaluating the query expression. A view definition causes the saving of an expression;the expression is substituted into queries using the view. A view of instructors without their salary: create view faculty as select ID, name, dept_name from instructor Find all instructors in the Biology department. select name from faculty where dept_name = 'Biology' Create a view of department salary totals create view departments_total_salary(dept_name, total_salary) as select dept_name, sum(salary) from instructor group by dept_name; sum() is an aggregate function (defined in DML) that returns a single sum value of all the salaries in the salary column of the instructor table belonging to the same department after the records have been grouped by the dept_name attribute. ( group by clause defined in DML). select * from departments_total_salary where dept_name = 'Biology' Returns the total salary of the Biology department and the information is extracted from the view called departments_total_salary created above. Defining views using other views. create view physics_fall_2009 as select course.course_id, sec_id, building, room_number from course, section where course.course_id = section.course_id and course.dept_name = 'Physics' and section.semester = 'Fall' and section.year = '2009' A view named physics_fall_2009 is created from a join of the relations course and section . create view physics_fall_2009_watson as select course_id, room_number from physics_fall_2009 where building= 'Watson' A view named physics_fall_2009_watson is defined using the view named physics_fall_2009 . It just contains the course_id and room_number from the tuples in the physics_fall_2009 view where the building is 'Watson'. View Expansion create view physics_fall_2009_watson as (select course_id, room_number from (select course.course_id, building, room_number from course, section where course.course_id = section.course_id and course.dept_name = 'Physics' and section.semester = 'Fall' and section.year = '2009') as foo where building= 'Watson') \u2022 A view relation v1 is said to depend directly on a view relation v2 if v2 is used in the expression defining v1. \u2022 A view relation v1 is said to depend on view relation v2 if either v1 depends directly on v2 or there is a path of dependencies from v1 to v2. \u2022 A view relation v is said to be recursive if it depends on itself. Let view v1 be defined by an expression e1 that may itself contain uses of view relations. \u2022 View expansion of an expression repeats the following replacement step: repeat Find any view relation vi in e1 Replace the view relation vi by the expression defining vi until no more view relations are present in e1 \u2022 As long as the view definitions are not recursive, this loop will terminate. Updating View Adding a new tuple to faculty view: insert into faculty values ('30765', 'Green', 'Biology') Inserts the tuple ('30765', 'Green', 'Biology', null) into the instructor relation. create view instructor_info as select ID, name, building from instructor, department where instructor.dept_name= department.dept_name insert into instructor_info values ('69987', 'White', 'Taylor') The above query results in an error: ERROR: cannot insert into view \"instructor_info\" DETAIL: Views that do not select from a single table or view are not automatically updatable. HINT: To enable inserting into the view, provide an INSTEAD OF INSERT trigger or an unconditional ON INSERT DO INSTEAD rule. SQL state: 55000 Which department, if multiple departments in Taylor? What if no department is in Taylor? Most SQL implementations allow updates only on simple views. The from clause has only one database relation. The select clause contains only attribute names of the relation, and does not have any expressions, aggregates, or distinct specification. Any attribute not listed in the select clause can be set to null. The query does not have a group by or having clause. create view history_instructors as select * from instructor where dept_name= 'History' What happens if we insert ('25566', 'Brown', 'Biology', 100000) into history instructors? The insert takes place successfully! Materialised Views Materializing a view: create a physical table containing all the tuples in the result of the query defining the view. If relations used in the query are updated, the materialized view result becomes out of date. Need to maintain the view, by updating the view whenever the underlying relations are updated. CREATE MATERIALIZED VIEW mymatview AS SELECT * FROM instructor; Cannot subsequently be directly updated and that the query used to create the materialized view is stored in exactly the same way that a view's query is stored, so that fresh data can be generated for the materialized view with: REFRESH MATERIALIZED VIEW mymatview; Creating Index Index: data structures used to speed up access to records with specified values for index attributes. Creating an index on the table student on the attribute studentID : create index studentID_index on student(ID) This allows the query: sql select * from student where ID = '12345' to be executed in an efficient way by making use of the index directly without making use of all the records of the relation. Creating User-defined types create type Dollars as (something numeric(12,2)); create table departmentproxy ( dept_name varchar (20), building varchar (15), budget Dollars) The above query creates a user-defined type Dollars to be used as a data type of the budget attribute in the table departmentproxy . Creating User-defined domains create domain degree_level varchar(10) constraint degree_level_test check (value in ('Bachelors', 'Masters', 'Doctorate')) Types and domains are similar. The above query constructs a new domain called degree_level which can have certain constraints applied on them as well.","title":"Ddl"},{"location":"ddl/#data-definition-language-ddl","text":"Here, we start by creating the University Database schema (given below) used in the recorded lectures to give the essence of the Data Definition Language (DDL) commands in SQL.","title":"DATA DEFINITION LANGUAGE (DDL)"},{"location":"ddl/#schema-for-university-database","text":"DDL consists of: Schema, Domain of attributes: char(n) varchar(n) int smallint numeric(p,d) real , double precision float Integrity Constraints not null primary key foreign key references r (Referential Integrity Constraint) Some more datatypes in SQL: date : Dates, containing a (4 digit) year, month and date. Example: date '2005-7-27' time : Time of day, in hours, minutes and seconds. Example: time '09:00:30' time '09:00:30.75' timestamp : date plus time of day. Example: timestamp '2005-7-27 09:00:30.75' interval : period of time. Example:interval '1' day Subtracting a date/time/timestamp value from another = interval value. Interval values can be added to date/time/timestamp values.","title":"Schema for University Database"},{"location":"ddl/#syntax-for-table-creation","text":"create table r (A1D1, A2D2, . . . , AnDn), (integrity-constraint1), . . . (integrity-constraintk)); where r = relation name. Ai = Name of the i'th attribute. Di = Name of the i'th domain. Let us start creating the University Database.","title":"SYNTAX for table creation"},{"location":"ddl/#creating-classroom-table","text":"create table classroom (building varchar(15), room_number varchar(7), capacity numeric(4,0), primary key (building, room_number) ); The above table has 3 columns: Attribute Domain Integrity Constraint building varchar(15) primary key (composite) room_number varchar(7) primary key (composite) capacity numeric(4,0) - Here, both building and room_number uniquely identify every tuple present in the table classroom. Thus, they form a composite primary key for the classroom table. Primary key is a key that uniquely identifies every tuple present in a relation. They must have unique non null values. Existence of more than one primary key makes it a composite primary key altogether. The domain type of varchar(15) of building means that a user can add any variable length string with a maximum limit of 15 characters. The domain type numeric(4,0) of capacity allows a total of 4 digits to be stored out of which 0 digits should be on the right hand side of the decimal point.","title":"Creating classroom table."},{"location":"ddl/#creating-table-department","text":"create table department (dept_name varchar(20), building varchar(15), budget numeric(12,2) check (budget > 0), primary key (dept_name) ); The above table has 3 columns: Attribute Domain Integrity Constraint dept_name varchar(20) primary key building varchar(15) - budget numeric(12,2) check (budget > 0) Here the integrity constraint check (budget > 0) ensures that all the values in the budget column should be greater than 0.","title":"Creating table department"},{"location":"ddl/#creating-table-course","text":"create table course (course_id varchar(8), title varchar(50), dept_name varchar(20), credits numeric(2,0) check (credits > 0), primary key (course_id), foreign key (dept_name) references department (dept_name) on delete set null ); The above table has 4 columns: Attribute Domain Integrity Constraint course_id varchar(8) primary key title varchar(50) - dept_name varchar(20) foreign key (dept_name) references department (dept_name) on delete set null credits numeric(2,0) check (credits > 0) Here, the attribute dept_name acts as a foreign key that refers to the primary key dept_name of the department table. It is used to link tables in SQL. Foreign key is an attribute in a table that refers to the primary key of another table and describes association between both the relations. Foreign key is associated with a foreign key constraint or Referential Integrity Constraint. It implies an Insert Constraint that specifies that a value cannot be inserted into the referencing table (Table with the foriegn key) if it does not exist in the referenced table (Table with the primary key). It implies a Delete Constraint that specifies that a value cannot be deleted from the referencing table (Table with the foriegn key) if it exists in the referenced table (Table with the primary key). The integrity contraint on delete set null acts on the foreign key dept_name . If the records in the base table department are deleted, the corresponding foreign key records are not deleted, they are instead, updated to NULL .","title":"Creating table course"},{"location":"ddl/#creating-table-instructor","text":"create table instructor (ID varchar(5), name varchar(20) not null, dept_name varchar(20), salary numeric(8,2) check (salary > 29000), primary key (ID), foreign key (dept_name) references department (dept_name) on delete set null ); The above table has 3 columns: Attribute Domain Integrity Constraint ID varchar(5) primary key name varchar(20) not null dept_name varchar(20) foreign key (dept_name) references department (dept_name) on delete set null","title":"Creating table instructor"},{"location":"ddl/#creating-table-section","text":"create table section (course_id varchar(8), sec_id varchar(8), semester varchar(6) check (semester in ('Fall', 'Winter', 'Spring', 'Summer')), year numeric(4,0) check (year > 1701 and year < 2100), building varchar(15), room_number varchar(7), time_slot_id varchar(4), primary key (course_id, sec_id, semester, year), foreign key (course_id) references course (course_id) on delete cascade, foreign key (building, room_number) references classroom (building, room_number) on delete set null ); The above table has 7 columns: Attribute Domain Integrity Constraint course_id varchar(8) primary key (composite), foreign key (course_id) references course (course_id) on delete cascade sec_id varchar(8) primary key (composite) semester varchar(6) check (semester in ('Fall', 'Winter', 'Spring', 'Summer')) year numeric(4,0) check (year > 1701 and year < 2100) building varchar(15) foreign key (building, room_number) references classroom (building, room_number) room_number varchar(7) foreign key (building, room_number) references classroom (building, room_number) time_slot_id varchar(4) - Hear we have 2 foreign keys: course_id - a single foreign key linking the table section with the table course having a single primary key course_id (building, room_number) - a composite foreign key linking the table classroom having a composite primary key (building, room_number) . on delete cascade is a referential integrity constraint that allows the deletion of a value from the base table if the value is existing in the referencing table without the violation of the delete contraint. Similarly the other tables have been created below...","title":"Creating table section"},{"location":"ddl/#creating-table-teaches","text":"create table teaches (ID varchar(5), course_id varchar(8), sec_id varchar(8), semester varchar(6), year numeric(4,0), primary key (ID, course_id, sec_id, semester, year), foreign key (course_id, sec_id, semester, year) references section (course_id, sec_id, semester, year) on delete cascade, foreign key (ID) references instructor (ID) on delete cascade );","title":"Creating table teaches"},{"location":"ddl/#creating-table-student","text":"create table student (ID varchar(5), name varchar(20) not null, dept_name varchar(20), tot_cred numeric(3,0) check (tot_cred >= 0), primary key (ID), foreign key (dept_name) references department (dept_name) on delete set null );","title":"Creating table student"},{"location":"ddl/#creating-table-takes","text":"create table takes (ID varchar(5), course_id varchar(8), sec_id varchar(8), semester varchar(6), year numeric(4,0), grade varchar(2), primary key (ID, course_id, sec_id, semester, year), foreign key (course_id, sec_id, semester, year) references section (course_id, sec_id, semester, year) on delete cascade, foreign key (ID) references student (ID) on delete cascade );","title":"Creating table takes"},{"location":"ddl/#creating-table-advisor","text":"create table advisor (s_ID varchar(5), i_ID varchar(5), primary key (s_ID), foreign key (i_ID) references instructor (ID) on delete set null, foreign key (s_ID) references student (ID) on delete cascade );","title":"Creating table advisor"},{"location":"ddl/#creating-table-time_slot","text":"create table time_slot (time_slot_id varchar(4), day varchar(1), start_hr numeric(2) check (start_hr >= 0 and start_hr < 24), start_min numeric(2) check (start_min >= 0 and start_min < 60), end_hr numeric(2) check (end_hr >= 0 and end_hr < 24), end_min numeric(2) check (end_min >= 0 and end_min < 60), primary key (time_slot_id, day, start_hr, start_min) );","title":"Creating table time_slot"},{"location":"ddl/#creating-table-prereq","text":"create table prereq (course_id varchar(8), prereq_id varchar(8), primary key (course_id, prereq_id), foreign key (course_id) references course (course_id) on delete cascade, foreign key (prereq_id) references course (course_id) ); Let us create a test table r to run the commands to modify the table. create table r (build varchar(15), room varchar(7), capa numeric(4,0), primary key (build, room) );","title":"Creating table prereq"},{"location":"ddl/#alter-command","text":"Used to modify already created tables in the database. Adding a column: alter table r add A D where r = name of the relation to be modified. A = Name of the new column to be added. D = Domain name of the new column A. ALTER TABLE r ADD newcol varchar(5) The above command adds a new attribute named newcol of domain type varchar(5) to the table r . Dropping an existing column: SYNTAX alter table r drop A where r = name of the relation A = name of the attribute to be dropped.","title":"ALTER command"},{"location":"ddl/#drop-command","text":"To remove an existing table from the database. SYNTAX drop table r where r = name of the existing table to be dropped. If the table r already exists, it will be dropped successfully. DROP TABLE Query returned successfully in 65 msec. But if it does not exist, an error message will be printed out. ERROR: table \"r\" does not exist SQL state: 42P01 Handling the error using 'IF EXISTS' clause: DROP TABLE IF EXISTS r; This will handle the error and raise a notice instead. NOTICE: table \"r\" does not exist, skipping DROP TABLE Query returned successfully in 77 msec.","title":"DROP command"},{"location":"ddl/#views","text":"Any relation that is not of the conceptual model but is made visible to a user as a \"virtual relation\". SYNTAX: create view v as <query expression> where query expression is any legal SQL expression. View definition is not the same as creating a new relation by evaluating the query expression. A view definition causes the saving of an expression;the expression is substituted into queries using the view. A view of instructors without their salary: create view faculty as select ID, name, dept_name from instructor Find all instructors in the Biology department. select name from faculty where dept_name = 'Biology' Create a view of department salary totals create view departments_total_salary(dept_name, total_salary) as select dept_name, sum(salary) from instructor group by dept_name; sum() is an aggregate function (defined in DML) that returns a single sum value of all the salaries in the salary column of the instructor table belonging to the same department after the records have been grouped by the dept_name attribute. ( group by clause defined in DML). select * from departments_total_salary where dept_name = 'Biology' Returns the total salary of the Biology department and the information is extracted from the view called departments_total_salary created above.","title":"Views:"},{"location":"ddl/#defining-views-using-other-views","text":"create view physics_fall_2009 as select course.course_id, sec_id, building, room_number from course, section where course.course_id = section.course_id and course.dept_name = 'Physics' and section.semester = 'Fall' and section.year = '2009' A view named physics_fall_2009 is created from a join of the relations course and section . create view physics_fall_2009_watson as select course_id, room_number from physics_fall_2009 where building= 'Watson' A view named physics_fall_2009_watson is defined using the view named physics_fall_2009 . It just contains the course_id and room_number from the tuples in the physics_fall_2009 view where the building is 'Watson'.","title":"Defining views using other views."},{"location":"ddl/#view-expansion","text":"create view physics_fall_2009_watson as (select course_id, room_number from (select course.course_id, building, room_number from course, section where course.course_id = section.course_id and course.dept_name = 'Physics' and section.semester = 'Fall' and section.year = '2009') as foo where building= 'Watson') \u2022 A view relation v1 is said to depend directly on a view relation v2 if v2 is used in the expression defining v1. \u2022 A view relation v1 is said to depend on view relation v2 if either v1 depends directly on v2 or there is a path of dependencies from v1 to v2. \u2022 A view relation v is said to be recursive if it depends on itself. Let view v1 be defined by an expression e1 that may itself contain uses of view relations. \u2022 View expansion of an expression repeats the following replacement step: repeat Find any view relation vi in e1 Replace the view relation vi by the expression defining vi until no more view relations are present in e1 \u2022 As long as the view definitions are not recursive, this loop will terminate.","title":"View Expansion"},{"location":"ddl/#updating-view","text":"Adding a new tuple to faculty view: insert into faculty values ('30765', 'Green', 'Biology') Inserts the tuple ('30765', 'Green', 'Biology', null) into the instructor relation. create view instructor_info as select ID, name, building from instructor, department where instructor.dept_name= department.dept_name insert into instructor_info values ('69987', 'White', 'Taylor') The above query results in an error: ERROR: cannot insert into view \"instructor_info\" DETAIL: Views that do not select from a single table or view are not automatically updatable. HINT: To enable inserting into the view, provide an INSTEAD OF INSERT trigger or an unconditional ON INSERT DO INSTEAD rule. SQL state: 55000 Which department, if multiple departments in Taylor? What if no department is in Taylor? Most SQL implementations allow updates only on simple views. The from clause has only one database relation. The select clause contains only attribute names of the relation, and does not have any expressions, aggregates, or distinct specification. Any attribute not listed in the select clause can be set to null. The query does not have a group by or having clause. create view history_instructors as select * from instructor where dept_name= 'History' What happens if we insert ('25566', 'Brown', 'Biology', 100000) into history instructors? The insert takes place successfully!","title":"Updating View"},{"location":"ddl/#materialised-views","text":"Materializing a view: create a physical table containing all the tuples in the result of the query defining the view. If relations used in the query are updated, the materialized view result becomes out of date. Need to maintain the view, by updating the view whenever the underlying relations are updated. CREATE MATERIALIZED VIEW mymatview AS SELECT * FROM instructor; Cannot subsequently be directly updated and that the query used to create the materialized view is stored in exactly the same way that a view's query is stored, so that fresh data can be generated for the materialized view with: REFRESH MATERIALIZED VIEW mymatview;","title":"Materialised Views"},{"location":"ddl/#creating-index","text":"Index: data structures used to speed up access to records with specified values for index attributes. Creating an index on the table student on the attribute studentID : create index studentID_index on student(ID) This allows the query: sql select * from student where ID = '12345' to be executed in an efficient way by making use of the index directly without making use of all the records of the relation.","title":"Creating Index"},{"location":"ddl/#creating-user-defined-types","text":"create type Dollars as (something numeric(12,2)); create table departmentproxy ( dept_name varchar (20), building varchar (15), budget Dollars) The above query creates a user-defined type Dollars to be used as a data type of the budget attribute in the table departmentproxy .","title":"Creating User-defined types"},{"location":"ddl/#creating-user-defined-domains","text":"create domain degree_level varchar(10) constraint degree_level_test check (value in ('Bachelors', 'Masters', 'Doctorate')) Types and domains are similar. The above query constructs a new domain called degree_level which can have certain constraints applied on them as well.","title":"Creating User-defined domains"},{"location":"dml/","text":"Home DATA MANIPULATION LANGUAGE (DML) Here we manipulate our defined university database by inserting and deleting records (rows). Along with manipulation, we also query our database in order to get the desired output. Insertion of records - SYNTAX insert into <tablename> values (<value1>, <value2>,....,<value n>); where the values are in the order of the columns in the schema of the relation. Inserting a record in table instructor insert into instructor values ('10211', 'Smith', 'Biology', 66000); Recall that the instructor table has the attributes in the order : ID, name, dept_name, salary . Hence the values are entered in the same order and are compatible with the domain types of each of the attributes. For example, '10211' is the ID and is written as a string because the domain of ID is varchar(5) . Inserting multiple rows SYNTAX: insert into <tablename> values (<value11>, <value12>,....,<value 1n>), (<value21>, <value22>,....,<value 2n>); Inserts multiple records in the relation. insert into instructor values ('10911', 'Smith', 'Biology', 66000), ('10201', 'Smita', 'Biology', 67000); Deletion of records - SYNTAX delete from <table_name> where <Predicate>; Deleting a record from table instructor delete from instructor where ID='10211' This deletes the row containing the ID as '10211' from the table instructor . Deleting all rows SYNTAX: delete from <table_name> delete from instructor This command deletes all the records in the instructor table. Truncate command syntax: Used to delete the entire data in the table. truncate table <table_name> where table_name = name of the table whose data to be deleted. truncate table instructor deletes the data inside the instructor table. Updating records: Modification of existing records. Update <table> set col1 = val1, col2 = val2, .... where <Predicate> where Update= keyword used to convey the update. table = name of the table to update. set= keyword to change a particular column value. where Predicate = apply the update wherever the specified condition is true. Increase salaries of instructors whose salary is over $100,000 by 3%, and all others by a 5% update instructor set salary = salary*1.03 where salary > 100000 update instructor set salary = salary*1.05 where salary <= 100000 Case Statements: Conditional Updates Case statements work like if-else statements in SQL. case when <predicate1> then <result1>, when <predicate2> then <result2>, .... else <resultn> end case marks the beginning of the block and end keyword marks the end. Inside the block, when and then keywords are used to convey that if predicate1 turns out to be true, then the query will return result1, and so on. else keyword is used to return a result when none of the above predicates evaluate to true. Increase salaries of instructors whose salary is over $100,000 by 3%, and all others by a 5% update instructor set salary = case when salary <= 100000 then salary * 1.05 else salary * 1.03 end In the above query, the salary of the instructor is replaced by 1.05 times the salary if salary<=>100000, else it is replaced by 1.03 times the salary. SQL QUERY SYNTAX: select A1, A2, . . . , An, from r1,r2, ...,rm where P where, Ai = Attribute name. ri = relation name. P = Predicate. SELECT CLAUSE - Lists the attributes required in the result. ( Projection operation in relational algebra) FROM CLAUSE - Specifies conditions that the result must satisfy. ( Selection predicate in relational algebra) WHERE CLAUSE - Lists the relations involved in the query. ( Cartesian product in relational algebra) Find the names of all instructors? select \"name\" from instructor select all \"name\" from instructor Both the above queries are equivalent and return all the values in name column from the instructor relation. The keyword all allows duplicates and is the default output if not specified. SQL allows duplicates. select distinct dept_name from instructor The keyword distinct removes duplicate values from the column dept_name of instructor table. select * from instructor * means all the attributes. Returns the entire table instructor with all attributes. select '437' Attribute is a literal without a from clause. Results a table with 1 column and a single row with value '437' . select '437' as blah The above returned column can be named as 'blah' . select \"437\" as blah Using \"\" instead of '' results in an error: ERROR: column \"437\" does not exist LINE 1: select \"437\" as blah ^ SQL state: 42703 Character: 8 select 'a' from instructor Attribute is a literal with a from clause. Returns a table with one column with a value 'A' in all the rows. Number of rows returned = Number of rows in the table instructor . select ID, name, salary/12 from instructor Can use arithmetic expressions (- +,-,*,/) in Select clause . Returns the ID , name and salary from instructor with all the values of the salary column divided by 12. The salary/12 column has no name. select ID, name, salary/12 as monthly_salary from instructor Here the salary/12 column has been renamed as monthly_salary using the 'as' keyword. select name from instructor where dept_name = 'Comp. Sci.' Returns a table with 1 column - name , containing the names of the instructors from the department 'Comp. Sci.' from instructor . select name from instructor where dept_name = 'Comp. Sci.' and salary > 80000 Logical connectives - AND,OR and NOT can be used in the where clause. Returns all instructors in Comp. Sci. dept with salary > 80000. Basic Operations: Cartesian Product select * from instructor, teaches Returns all attributes in the cartesian product of instructor and teaches . mn rows returned where m= Number of rows in instructor, n= Number of rows in teaches. Examples: Find the names of all instructors who have taught some course and the course id. select \"name\", course_id from instructor,teaches where instructor.ID = teaches.ID Returns a relation with 2 columns name (names of the instructors) and course_id (ID of the course they taught). Find the names of all instructors in the Art department who have taught some course and the course id. select \"name\", course_id from instructor,teaches where instructor.ID = teaches.ID and instructor.dept_name = 'Art' Note: In the above queries, the attribute name has been written in double quotes because it is a built-in type in postgresql. Although the query gives the same result without the double quotes, enclosing the keywords in quotes is a good practice to distinguish them from the attribute names of the relation. AS Operator Syntax: old_name as new_name Find the names of all instructors who have a higher salary than some instructor in 'Comp. Sci'. select distinct T.name from instructor as T, instructor as S where T.salary > S.salary and S.dept_name = 'Comp. Sci' Here the 'AS' Operator is used to rename the relations. In order to perform a self cartesian product, we renamed the instructor table as T and the other as S. This enables us to use the attributes of the 2 instructor tables in a specific way in the where clause. 'AS' Keyword is optional and can be omitted: select distinct T.name from instructor T, instructor S where T.salary > S.salary and S.dept_name = 'Comp. Sci' String Operators like operator Find the names of all instructors whose name includes the substring \"dar\". select name from instructor where name like '%dar%' Here, the like operator compares the strings: percent (%) - matches any substring. underscore (_) - matches any character. Names like Sardar , Darwin, Sardarwin ,etc. will be matched. Match the string \"100%\" like '100%' escape '\\' select name from instructor where name like '___' Here, 3 underscores(_) have been used which will match any string of exactly three characters. select name from instructor where name like '___%' The above query matches any string of at least three characters. String Concatenation: select 'str1' || 'str2' Output = One single column named 'str1str2'. select 'str1' || 'something ' || 'str2' Ouput = One single column named 'str1somethingstr2'. select 'str1' || NULL AS res Concatenating a string with NULL value returns NULL. select concat('str1','str2') The concat() function takes 2 strings and concatenates them in the same order. Output = One single column named 'str1str2'. select lower(name) from instructor lower() function takes the name column from the instructor and converts all the values in the column in lower case. select upper(name) from instructor upper() function takes the name column from the instructor and converts all the values in the column in upper case. SELECT name,length(name) as \"Length of Name\" FROM instructor WHERE length(name)>7; length() function takes the name column from the instructor and calculates the length of all the values in the column and renames the column as 'Length of Name' and filters out only those names having length greater than 7 as per the predicate in the where clause. select id,name, substring(name,1,4) \"1st 4 characters of name\" from instructor substring(str,start_index,end_index) function takes 3 arguments- string, starting index, ending index of the substring to be sliced from the string. The above query outputs a relation with 3 columns: id,name,1st 4 characters of name . The third column contains the substrings corresponding to the first 4 characters of the names. Ordering the tuples: select distinct name from instructor order by name Output: List in alphabetic order the names of all instructors. (Ascending order by default.) asc for ascending and desc for descneding can be specified explicitly. select distinct name from instructor order by name desc Sorting by multiple attributes: select name , dept_name from instructor order by dept_name desc, name desc Here the query first sorts on dept_name attribute in descending order and then sorts name column in descending order on the tuples with same dept_name . Selecting number of tuples in the output select distinct name from instructor order by name limit 10 Returns only top 10 tuples. Not all database systems support the SELECT TOP clause. ORACLE uses: select distinct name from instructor order by name fetch first 10 rows only Where clause predicates: Between operator Find the names of all instructors with salary between $90, 000 and $100, 000 (that is, \u2265 $90, 000 and \u2264 $100, 000) select name from instructor where salary between 90000 and 100000 Tuple Comparison select name, course_id from instructor,teaches where (instructor.ID, dept_name) = (teaches.ID, 'Biology'); Can compare a tuple with another in the where clause. Ouput = A relation where instructor.ID matches with teaches.ID and the dept_name is 'Biology'. In operator select name from instructor where dept_name in ('Comp. Sci.', 'Biology') Used to specify multiple values in a where clause. Used as a shorthand for multiple or conditions. Outputs= All the names of the instructors having 'Comp. Sci.' or 'Biology' as the dept_name . Set Operations Union Combines the result of two or more select statements. Find courses that ran in Fall 2009 or in Spring 2010 (select course_id from section where semester = 'Fall' and year = 2009) union (select course_id from section where semester = 'Spring' and year = 2010) Intersection Returns the common tuples from 2 or more select statements. Find courses that ran in Fall 2009 and in Spring 2010. (select course_id from section where semester = 'Fall' and year = 2009) intersect (select course_id from section where semester = 'Spring' and year = 2010) Set Difference Returns all the rows from the first select statement that are not returned by the second select statement. Find courses that ran in Fall 2009 but not in Spring 2010 (select course_id from section where semester = 'Fall' and year = 2009) except (select course_id from section where semester = 'Spring' and year = 2010) Note: To retain all duplicates, use the corresponding multiset versions union all , intersect all , and except all . Corresponding multi-set versions: (select course_id from section where semester = 'Fall' and year = 2009) union all (select course_id from section where semester = 'Spring' and year = 2010) (select course_id from section where semester = 'Fall' and year = 2009) intersect all (select course_id from section where semester = 'Spring' and year = 2010) (select course_id from section where semester = 'Fall' and year = 2009) except all (select course_id from section where semester = 'Spring' and year = 2010) EXAMPLE: Find the salaries of all instructors that are less than the largest salary (select distinct T.salary from instructor as T, instructor as S where T.salary < S.salary) except (select distinct salary from instructor ) The first query returns salaries of all instructors that are less than the largest salary. The second query returns the salaries of all instructors. The overall output is the largest salary of all instructors. IS NULL predicate Can be used to check for null values. Null values cannot be checked via comparison operators, such as =, <, or <>. Find all instructors whose salary is null. select name from instructor where salary is null Aggregate Functions Operate on the multiset of values of a column of a relation, and return a value. avg: average value select avg(salary) from instructor where dept_name = 'Comp. Sci' Returns the average salary of instructors in the Computer Science department. count: number of values select count(distinct ID) from teaches where semester = 'Spring' and year = 2010 Returns the total number of instructors who teach a course in the Spring 2010 semester. select count(*) from courses; Returns the number of tuples in the course relation. min: minimum value select min(salary) from instructor where dept_name = 'Comp. Sci' Returns the minimum salary of all instructors in the Computer Science department. max: maximum value select max(salary) from instructor where dept_name = 'Comp. Sci' Returns the maximum salary of all instructors in the Computer Science department. sum: sum of values select sum(salary) from instructor where dept_name = 'Comp. Sci' Returns the Sum of the salary of all instructors in the Computer Science department. Group By clause: Groups the attributes which have Identical values on some other attribute by passing them in some function. select dept_name, avg(salary) as avg_salary from instructor group by dept_name; Note: Attributes in select clause outside of aggregate functions must appear in group by list. /* erroneous query */ select dept_name, ID, avg(salary) from instructor group by dept_name; ERROR: column \"instructor.id\" must appear in the GROUP BY clause or be used in an aggregate function LINE 1: select dept_name, ID, avg(salary) ^ SQL state: 42803 Character: 19 Having Clause: Used to apply a predicate after the formation of the groups (predicate on the groups). Find the names and average salaries of all departments whose average salary is greater than 42000. select dept_name, avg(salary) from instructor group by dept_name having avg(salary) > 42000; Null values All aggregate operations except count(*) ignore tuples with null values on the aggregated attributes. select sum(salary) from instructor; Returns null if no non-null salary. Ignores the null values. select count(salary) from instructor; Returns 0 if all are null values in the salary column. Does not ignore the null values. Nested Subqueries: select-from-where expression nested within another query. SYNTAX select A1, A2, . . . , An from r1,r2, . . . ,rm where P where Ai : a subquery that generates a single value. ri : any valid subquery. P :an expression of the form: B operation (subquery) where B is an attribute. Subqueries in the Where Clause: Set Membership Find courses offered in Fall 2009 and in Spring 2010. (intersect example). select distinct course_id from section where semester ='Fall' and year = 2009 and course_id in (select course_id from section where semester ='Spring' and year = 2010) The subquery returns the course_id from section table with Spring semester and 2010 as the year. Here the in operator is used to check whether the course_id exists in the result of the subquery specified in the where clause. Find courses offered in Fall 2009 but not in Spring 2010. (except example) select distinct course_id from section where semester ='Fall' and year = 2009 and course_id not in (select course_id from section where semester ='Spring' and year = 2010) This query returns a result opposite to the above query due to the not in operator. Find the total number of (distinct) students who have taken course sections taught by the instructor with ID 4233. select count(distinct id) from takes where (course_id, sec_id, semester, takes.year) in (select course_id, sec_id, semester, teaches.year from teaches where teaches.id like '4233') Set Comparison some clause refers to existential quantification. Find names of instructors with salary greater than that of some (at least one) instructor in the Biology department. select name from instructor where salary > some(select salary from instructor where dept_name = 'Biology') The above query checks if the salary of the instructor is greater than any result returned by the subquery returning the salary of the instructor in Biology department. all clause refers to universal quantification. Find the names of all instructors whose salary is greater than the salary of all instructors in the Biology department. select name from instructor where salary > all(select salary from instructor where dept_name = 'Biology') The all clause checks if the salary of the instructor is greater than all the salaries returned by the subquery in the where clause. Exists clause: testing empty relations. The exists construct returns the value true if the argument subquery is nonempty, else false. Find all courses taught in both the Fall 2009 semester and in the Spring 2010 semester. select course_id from section as S where semester = 'Fall' and year = 2009 and exists (select * from section as T where semester = 'Spring' and year = 2010 and S.course_id = T.course_id) The exists clause checks if something is returned by the enclosed subquery. If yes, it is set to true, else false. Correlation name \u2013 variable S in the outer query. Correlated subquery \u2013 the inner query Similarly the not exists clause works in an opposite way: select distinct S.ID, S.name from student as S where not exists ( (select course_id from course where dept_name = 'Biology') except (select T.course_id from takes as T where S.ID = T.ID)); The above contains 2 nested queries. The first nested query lists all courses offered in Biology. The second one lists all courses a particular student took. The entire query returns all students who have taken all courses offered in the Biology department. Subqueries in the FROM clause Find the average instructors' salaries of those departments where the average salary is greater than $42,000. select dept_name, avg_salary from (select dept_name, avg(salary) as avg_salary from instructor group by dept_name) as foo where avg_salary > 42000 It is necessary to give an alias to the relation returned by the subquery in the from clause to be able to work on it. Here the subquery returns the average salary of the instructors in each department and names that table as 'foo'. The outer query then extracts the department names and average salaries of the departments where the average salary is greater than 42000. With clause: Defines a temporary relation whose definition is available only to the query in which the with clause occurs. Find all departments with the maximum budget. with max_budget(value) as (select max(budget) from department) select department.dept_name from department, max_budget where department.budget=max_budget.value max_budget(value) is a temporary relation defined using with clause that returns the maximum budget from the department table and is stored in max_budget. This temporary relation is used to extract the department name by doing a cross product of the relation max_budget and department where the budget of the department is equal to the value of the max_budget relation. Subqueries in Select Clause Used for scalar subqueries : queries which return a single value. Gives Runtime error if a subquery in select clause returns more than a single value. List all departments along with the number of instructors in each department select dept_name, (select count(*) from instructor where department.dept_name = instructor.dept_name) as num_instructors from department The above nested query returns a single value as the count of instructors in a department and aliases it as num_instructors. The department name and the number of instructors is then finally displayed using the outer query. Joins: Cartesian product which requires that tuples in the two relations match (under some condition). Cross Join Returns the Cartesian product of rows from tables in the join. Explicit select * from instructor cross join department; OR Implicit select * from instructor, department; Inner Join Returns records having same value in a common column of the tables. select * from course inner join prereq on course.course_id = prereq.course_id The above query returns all the records from the table course and instructor where the values in the common column course_id match. Note that the column course_id is repeated as it is contained in both the relations. Self Join Sometimes we require a join with the same table in order to retrieve the required result. Self join is used for that and the table names are changed in order to distinctly identify the same relations and apply conditions on them. SYNTAX: select * from <table_name> <aliased_name1> natural join <table_name> <aliased_name2> select * from course c1 inner join course c2 on c1.course_id = c2.course_id The above query returns then entire course relation with duplicate columns. Natural Join It is an inner join that eliminates the repeated column. It is an implicit join and does not require the specification of the key. It joins on the columns with same name in the tables implicitly. select * from course natural join prereq Theta Join Merges 2 tables on some condition represented by theta. Theta condition includes all comparison operators. select * from course inner join prereq on course.course_id>prereq.course_id Returns the join of the course and prereq table on the join condition course.course_id > prereq.course_id. If the comparison operator is replaced by '=' operator, we get our basic join also called 'equijoin' Outer Join Computes the join and then adds tuples from one relation that does not match tuples in the other relation to the result of the join. Avoids loss of information. Null values are used to fill up the attributes of rows in which the common attribute does not match. It is of 3 types: Left Outer Join Returns all records of the first table (left table) and the records that match in both the tables according to the join condition. select * from course natural left outer join prereq Returns all the rows in which the course_id in course and prereq match, as well as the rows from the left column course which do not match. Right Outer Join Returns all records of the second table (right table) and the records that match in both the tables according to the join condition. select * from course natural right outer join prereq Returns all the rows in which the course_id in course and prereq match, as well as the rows from the right column prereq which do not match. Full Outer Join Returns the records from both the tables that match according to the join condition as well as those which do not match. select * from course natural full outer join prereq Returns all the rows in which the course_id in course and prereq match, as well as the rows from both the columns which do not match. NOTE: Those records which do not match according to the join condition have null values in those attributes not common to both the tables.","title":"Dml"},{"location":"dml/#data-manipulation-language-dml","text":"Here we manipulate our defined university database by inserting and deleting records (rows). Along with manipulation, we also query our database in order to get the desired output.","title":"DATA MANIPULATION LANGUAGE (DML)"},{"location":"dml/#insertion-of-records-syntax","text":"insert into <tablename> values (<value1>, <value2>,....,<value n>); where the values are in the order of the columns in the schema of the relation.","title":"Insertion of records - SYNTAX"},{"location":"dml/#inserting-a-record-in-table-instructor","text":"insert into instructor values ('10211', 'Smith', 'Biology', 66000); Recall that the instructor table has the attributes in the order : ID, name, dept_name, salary . Hence the values are entered in the same order and are compatible with the domain types of each of the attributes. For example, '10211' is the ID and is written as a string because the domain of ID is varchar(5) .","title":"Inserting a record in table instructor"},{"location":"dml/#inserting-multiple-rows","text":"SYNTAX: insert into <tablename> values (<value11>, <value12>,....,<value 1n>), (<value21>, <value22>,....,<value 2n>); Inserts multiple records in the relation. insert into instructor values ('10911', 'Smith', 'Biology', 66000), ('10201', 'Smita', 'Biology', 67000);","title":"Inserting multiple rows"},{"location":"dml/#deletion-of-records-syntax","text":"delete from <table_name> where <Predicate>;","title":"Deletion of records - SYNTAX"},{"location":"dml/#deleting-a-record-from-table-instructor","text":"delete from instructor where ID='10211' This deletes the row containing the ID as '10211' from the table instructor .","title":"Deleting a record from table instructor"},{"location":"dml/#deleting-all-rows","text":"SYNTAX: delete from <table_name> delete from instructor This command deletes all the records in the instructor table.","title":"Deleting all rows"},{"location":"dml/#truncate-command-syntax","text":"Used to delete the entire data in the table. truncate table <table_name> where table_name = name of the table whose data to be deleted. truncate table instructor deletes the data inside the instructor table.","title":"Truncate command syntax:"},{"location":"dml/#updating-records","text":"Modification of existing records. Update <table> set col1 = val1, col2 = val2, .... where <Predicate> where Update= keyword used to convey the update. table = name of the table to update. set= keyword to change a particular column value. where Predicate = apply the update wherever the specified condition is true. Increase salaries of instructors whose salary is over $100,000 by 3%, and all others by a 5% update instructor set salary = salary*1.03 where salary > 100000 update instructor set salary = salary*1.05 where salary <= 100000","title":"Updating records:"},{"location":"dml/#case-statements-conditional-updates","text":"Case statements work like if-else statements in SQL. case when <predicate1> then <result1>, when <predicate2> then <result2>, .... else <resultn> end case marks the beginning of the block and end keyword marks the end. Inside the block, when and then keywords are used to convey that if predicate1 turns out to be true, then the query will return result1, and so on. else keyword is used to return a result when none of the above predicates evaluate to true. Increase salaries of instructors whose salary is over $100,000 by 3%, and all others by a 5% update instructor set salary = case when salary <= 100000 then salary * 1.05 else salary * 1.03 end In the above query, the salary of the instructor is replaced by 1.05 times the salary if salary<=>100000, else it is replaced by 1.03 times the salary.","title":"Case Statements: Conditional Updates"},{"location":"dml/#sql-query-syntax","text":"select A1, A2, . . . , An, from r1,r2, ...,rm where P where, Ai = Attribute name. ri = relation name. P = Predicate. SELECT CLAUSE - Lists the attributes required in the result. ( Projection operation in relational algebra) FROM CLAUSE - Specifies conditions that the result must satisfy. ( Selection predicate in relational algebra) WHERE CLAUSE - Lists the relations involved in the query. ( Cartesian product in relational algebra) Find the names of all instructors? select \"name\" from instructor select all \"name\" from instructor Both the above queries are equivalent and return all the values in name column from the instructor relation. The keyword all allows duplicates and is the default output if not specified. SQL allows duplicates. select distinct dept_name from instructor The keyword distinct removes duplicate values from the column dept_name of instructor table. select * from instructor * means all the attributes. Returns the entire table instructor with all attributes. select '437' Attribute is a literal without a from clause. Results a table with 1 column and a single row with value '437' . select '437' as blah The above returned column can be named as 'blah' . select \"437\" as blah Using \"\" instead of '' results in an error: ERROR: column \"437\" does not exist LINE 1: select \"437\" as blah ^ SQL state: 42703 Character: 8 select 'a' from instructor Attribute is a literal with a from clause. Returns a table with one column with a value 'A' in all the rows. Number of rows returned = Number of rows in the table instructor . select ID, name, salary/12 from instructor Can use arithmetic expressions (- +,-,*,/) in Select clause . Returns the ID , name and salary from instructor with all the values of the salary column divided by 12. The salary/12 column has no name. select ID, name, salary/12 as monthly_salary from instructor Here the salary/12 column has been renamed as monthly_salary using the 'as' keyword. select name from instructor where dept_name = 'Comp. Sci.' Returns a table with 1 column - name , containing the names of the instructors from the department 'Comp. Sci.' from instructor . select name from instructor where dept_name = 'Comp. Sci.' and salary > 80000 Logical connectives - AND,OR and NOT can be used in the where clause. Returns all instructors in Comp. Sci. dept with salary > 80000.","title":"SQL QUERY SYNTAX:"},{"location":"dml/#basic-operations","text":"","title":"Basic Operations:"},{"location":"dml/#cartesian-product","text":"select * from instructor, teaches Returns all attributes in the cartesian product of instructor and teaches . mn rows returned where m= Number of rows in instructor, n= Number of rows in teaches.","title":"Cartesian Product"},{"location":"dml/#examples","text":"Find the names of all instructors who have taught some course and the course id. select \"name\", course_id from instructor,teaches where instructor.ID = teaches.ID Returns a relation with 2 columns name (names of the instructors) and course_id (ID of the course they taught). Find the names of all instructors in the Art department who have taught some course and the course id. select \"name\", course_id from instructor,teaches where instructor.ID = teaches.ID and instructor.dept_name = 'Art' Note: In the above queries, the attribute name has been written in double quotes because it is a built-in type in postgresql. Although the query gives the same result without the double quotes, enclosing the keywords in quotes is a good practice to distinguish them from the attribute names of the relation.","title":"Examples:"},{"location":"dml/#as-operator","text":"Syntax: old_name as new_name Find the names of all instructors who have a higher salary than some instructor in 'Comp. Sci'. select distinct T.name from instructor as T, instructor as S where T.salary > S.salary and S.dept_name = 'Comp. Sci' Here the 'AS' Operator is used to rename the relations. In order to perform a self cartesian product, we renamed the instructor table as T and the other as S. This enables us to use the attributes of the 2 instructor tables in a specific way in the where clause. 'AS' Keyword is optional and can be omitted: select distinct T.name from instructor T, instructor S where T.salary > S.salary and S.dept_name = 'Comp. Sci'","title":"AS Operator"},{"location":"dml/#string-operators","text":"","title":"String Operators"},{"location":"dml/#like-operator","text":"Find the names of all instructors whose name includes the substring \"dar\". select name from instructor where name like '%dar%' Here, the like operator compares the strings: percent (%) - matches any substring. underscore (_) - matches any character. Names like Sardar , Darwin, Sardarwin ,etc. will be matched. Match the string \"100%\" like '100%' escape '\\' select name from instructor where name like '___' Here, 3 underscores(_) have been used which will match any string of exactly three characters. select name from instructor where name like '___%' The above query matches any string of at least three characters.","title":"like operator"},{"location":"dml/#string-concatenation","text":"select 'str1' || 'str2' Output = One single column named 'str1str2'. select 'str1' || 'something ' || 'str2' Ouput = One single column named 'str1somethingstr2'. select 'str1' || NULL AS res Concatenating a string with NULL value returns NULL. select concat('str1','str2') The concat() function takes 2 strings and concatenates them in the same order. Output = One single column named 'str1str2'. select lower(name) from instructor lower() function takes the name column from the instructor and converts all the values in the column in lower case. select upper(name) from instructor upper() function takes the name column from the instructor and converts all the values in the column in upper case. SELECT name,length(name) as \"Length of Name\" FROM instructor WHERE length(name)>7; length() function takes the name column from the instructor and calculates the length of all the values in the column and renames the column as 'Length of Name' and filters out only those names having length greater than 7 as per the predicate in the where clause. select id,name, substring(name,1,4) \"1st 4 characters of name\" from instructor substring(str,start_index,end_index) function takes 3 arguments- string, starting index, ending index of the substring to be sliced from the string. The above query outputs a relation with 3 columns: id,name,1st 4 characters of name . The third column contains the substrings corresponding to the first 4 characters of the names.","title":"String Concatenation:"},{"location":"dml/#ordering-the-tuples","text":"select distinct name from instructor order by name Output: List in alphabetic order the names of all instructors. (Ascending order by default.) asc for ascending and desc for descneding can be specified explicitly. select distinct name from instructor order by name desc Sorting by multiple attributes: select name , dept_name from instructor order by dept_name desc, name desc Here the query first sorts on dept_name attribute in descending order and then sorts name column in descending order on the tuples with same dept_name .","title":"Ordering the tuples:"},{"location":"dml/#selecting-number-of-tuples-in-the-output","text":"select distinct name from instructor order by name limit 10 Returns only top 10 tuples. Not all database systems support the SELECT TOP clause. ORACLE uses: select distinct name from instructor order by name fetch first 10 rows only","title":"Selecting number of tuples in the output"},{"location":"dml/#where-clause-predicates","text":"","title":"Where clause predicates:"},{"location":"dml/#between-operator","text":"Find the names of all instructors with salary between $90, 000 and $100, 000 (that is, \u2265 $90, 000 and \u2264 $100, 000) select name from instructor where salary between 90000 and 100000","title":"Between operator"},{"location":"dml/#tuple-comparison","text":"select name, course_id from instructor,teaches where (instructor.ID, dept_name) = (teaches.ID, 'Biology'); Can compare a tuple with another in the where clause. Ouput = A relation where instructor.ID matches with teaches.ID and the dept_name is 'Biology'.","title":"Tuple Comparison"},{"location":"dml/#in-operator","text":"select name from instructor where dept_name in ('Comp. Sci.', 'Biology') Used to specify multiple values in a where clause. Used as a shorthand for multiple or conditions. Outputs= All the names of the instructors having 'Comp. Sci.' or 'Biology' as the dept_name .","title":"In operator"},{"location":"dml/#set-operations","text":"","title":"Set Operations"},{"location":"dml/#union","text":"Combines the result of two or more select statements. Find courses that ran in Fall 2009 or in Spring 2010 (select course_id from section where semester = 'Fall' and year = 2009) union (select course_id from section where semester = 'Spring' and year = 2010)","title":"Union"},{"location":"dml/#intersection","text":"Returns the common tuples from 2 or more select statements. Find courses that ran in Fall 2009 and in Spring 2010. (select course_id from section where semester = 'Fall' and year = 2009) intersect (select course_id from section where semester = 'Spring' and year = 2010)","title":"Intersection"},{"location":"dml/#set-difference","text":"Returns all the rows from the first select statement that are not returned by the second select statement. Find courses that ran in Fall 2009 but not in Spring 2010 (select course_id from section where semester = 'Fall' and year = 2009) except (select course_id from section where semester = 'Spring' and year = 2010) Note: To retain all duplicates, use the corresponding multiset versions union all , intersect all , and except all . Corresponding multi-set versions: (select course_id from section where semester = 'Fall' and year = 2009) union all (select course_id from section where semester = 'Spring' and year = 2010) (select course_id from section where semester = 'Fall' and year = 2009) intersect all (select course_id from section where semester = 'Spring' and year = 2010) (select course_id from section where semester = 'Fall' and year = 2009) except all (select course_id from section where semester = 'Spring' and year = 2010) EXAMPLE: Find the salaries of all instructors that are less than the largest salary (select distinct T.salary from instructor as T, instructor as S where T.salary < S.salary) except (select distinct salary from instructor ) The first query returns salaries of all instructors that are less than the largest salary. The second query returns the salaries of all instructors. The overall output is the largest salary of all instructors.","title":"Set Difference"},{"location":"dml/#is-null-predicate","text":"Can be used to check for null values. Null values cannot be checked via comparison operators, such as =, <, or <>. Find all instructors whose salary is null. select name from instructor where salary is null","title":"IS NULL predicate"},{"location":"dml/#aggregate-functions","text":"Operate on the multiset of values of a column of a relation, and return a value. avg: average value select avg(salary) from instructor where dept_name = 'Comp. Sci' Returns the average salary of instructors in the Computer Science department. count: number of values select count(distinct ID) from teaches where semester = 'Spring' and year = 2010 Returns the total number of instructors who teach a course in the Spring 2010 semester. select count(*) from courses; Returns the number of tuples in the course relation. min: minimum value select min(salary) from instructor where dept_name = 'Comp. Sci' Returns the minimum salary of all instructors in the Computer Science department. max: maximum value select max(salary) from instructor where dept_name = 'Comp. Sci' Returns the maximum salary of all instructors in the Computer Science department. sum: sum of values select sum(salary) from instructor where dept_name = 'Comp. Sci' Returns the Sum of the salary of all instructors in the Computer Science department.","title":"Aggregate Functions"},{"location":"dml/#group-by-clause","text":"Groups the attributes which have Identical values on some other attribute by passing them in some function. select dept_name, avg(salary) as avg_salary from instructor group by dept_name; Note: Attributes in select clause outside of aggregate functions must appear in group by list. /* erroneous query */ select dept_name, ID, avg(salary) from instructor group by dept_name; ERROR: column \"instructor.id\" must appear in the GROUP BY clause or be used in an aggregate function LINE 1: select dept_name, ID, avg(salary) ^ SQL state: 42803 Character: 19","title":"Group By clause:"},{"location":"dml/#having-clause","text":"Used to apply a predicate after the formation of the groups (predicate on the groups). Find the names and average salaries of all departments whose average salary is greater than 42000. select dept_name, avg(salary) from instructor group by dept_name having avg(salary) > 42000;","title":"Having Clause:"},{"location":"dml/#null-values","text":"All aggregate operations except count(*) ignore tuples with null values on the aggregated attributes. select sum(salary) from instructor; Returns null if no non-null salary. Ignores the null values. select count(salary) from instructor; Returns 0 if all are null values in the salary column. Does not ignore the null values.","title":"Null values"},{"location":"dml/#nested-subqueries","text":"select-from-where expression nested within another query. SYNTAX select A1, A2, . . . , An from r1,r2, . . . ,rm where P where Ai : a subquery that generates a single value. ri : any valid subquery. P :an expression of the form: B operation (subquery) where B is an attribute.","title":"Nested Subqueries:"},{"location":"dml/#subqueries-in-the-where-clause","text":"","title":"Subqueries in the Where Clause:"},{"location":"dml/#set-membership","text":"Find courses offered in Fall 2009 and in Spring 2010. (intersect example). select distinct course_id from section where semester ='Fall' and year = 2009 and course_id in (select course_id from section where semester ='Spring' and year = 2010) The subquery returns the course_id from section table with Spring semester and 2010 as the year. Here the in operator is used to check whether the course_id exists in the result of the subquery specified in the where clause. Find courses offered in Fall 2009 but not in Spring 2010. (except example) select distinct course_id from section where semester ='Fall' and year = 2009 and course_id not in (select course_id from section where semester ='Spring' and year = 2010) This query returns a result opposite to the above query due to the not in operator. Find the total number of (distinct) students who have taken course sections taught by the instructor with ID 4233. select count(distinct id) from takes where (course_id, sec_id, semester, takes.year) in (select course_id, sec_id, semester, teaches.year from teaches where teaches.id like '4233')","title":"Set Membership"},{"location":"dml/#set-comparison","text":"some clause refers to existential quantification. Find names of instructors with salary greater than that of some (at least one) instructor in the Biology department. select name from instructor where salary > some(select salary from instructor where dept_name = 'Biology') The above query checks if the salary of the instructor is greater than any result returned by the subquery returning the salary of the instructor in Biology department. all clause refers to universal quantification. Find the names of all instructors whose salary is greater than the salary of all instructors in the Biology department. select name from instructor where salary > all(select salary from instructor where dept_name = 'Biology') The all clause checks if the salary of the instructor is greater than all the salaries returned by the subquery in the where clause.","title":"Set Comparison"},{"location":"dml/#exists-clause-testing-empty-relations","text":"The exists construct returns the value true if the argument subquery is nonempty, else false. Find all courses taught in both the Fall 2009 semester and in the Spring 2010 semester. select course_id from section as S where semester = 'Fall' and year = 2009 and exists (select * from section as T where semester = 'Spring' and year = 2010 and S.course_id = T.course_id) The exists clause checks if something is returned by the enclosed subquery. If yes, it is set to true, else false. Correlation name \u2013 variable S in the outer query. Correlated subquery \u2013 the inner query Similarly the not exists clause works in an opposite way: select distinct S.ID, S.name from student as S where not exists ( (select course_id from course where dept_name = 'Biology') except (select T.course_id from takes as T where S.ID = T.ID)); The above contains 2 nested queries. The first nested query lists all courses offered in Biology. The second one lists all courses a particular student took. The entire query returns all students who have taken all courses offered in the Biology department.","title":"Exists clause: testing empty relations."},{"location":"dml/#subqueries-in-the-from-clause","text":"Find the average instructors' salaries of those departments where the average salary is greater than $42,000. select dept_name, avg_salary from (select dept_name, avg(salary) as avg_salary from instructor group by dept_name) as foo where avg_salary > 42000 It is necessary to give an alias to the relation returned by the subquery in the from clause to be able to work on it. Here the subquery returns the average salary of the instructors in each department and names that table as 'foo'. The outer query then extracts the department names and average salaries of the departments where the average salary is greater than 42000.","title":"Subqueries in the FROM clause"},{"location":"dml/#with-clause","text":"Defines a temporary relation whose definition is available only to the query in which the with clause occurs. Find all departments with the maximum budget. with max_budget(value) as (select max(budget) from department) select department.dept_name from department, max_budget where department.budget=max_budget.value max_budget(value) is a temporary relation defined using with clause that returns the maximum budget from the department table and is stored in max_budget. This temporary relation is used to extract the department name by doing a cross product of the relation max_budget and department where the budget of the department is equal to the value of the max_budget relation.","title":"With clause:"},{"location":"dml/#subqueries-in-select-clause","text":"Used for scalar subqueries : queries which return a single value. Gives Runtime error if a subquery in select clause returns more than a single value. List all departments along with the number of instructors in each department select dept_name, (select count(*) from instructor where department.dept_name = instructor.dept_name) as num_instructors from department The above nested query returns a single value as the count of instructors in a department and aliases it as num_instructors. The department name and the number of instructors is then finally displayed using the outer query.","title":"Subqueries in Select Clause"},{"location":"dml/#joins","text":"Cartesian product which requires that tuples in the two relations match (under some condition).","title":"Joins:"},{"location":"dml/#cross-join","text":"Returns the Cartesian product of rows from tables in the join. Explicit select * from instructor cross join department; OR Implicit select * from instructor, department;","title":"Cross Join"},{"location":"dml/#inner-join","text":"Returns records having same value in a common column of the tables. select * from course inner join prereq on course.course_id = prereq.course_id The above query returns all the records from the table course and instructor where the values in the common column course_id match. Note that the column course_id is repeated as it is contained in both the relations.","title":"Inner Join"},{"location":"dml/#self-join","text":"Sometimes we require a join with the same table in order to retrieve the required result. Self join is used for that and the table names are changed in order to distinctly identify the same relations and apply conditions on them. SYNTAX: select * from <table_name> <aliased_name1> natural join <table_name> <aliased_name2> select * from course c1 inner join course c2 on c1.course_id = c2.course_id The above query returns then entire course relation with duplicate columns.","title":"Self Join"},{"location":"dml/#natural-join","text":"It is an inner join that eliminates the repeated column. It is an implicit join and does not require the specification of the key. It joins on the columns with same name in the tables implicitly. select * from course natural join prereq","title":"Natural Join"},{"location":"dml/#theta-join","text":"Merges 2 tables on some condition represented by theta. Theta condition includes all comparison operators. select * from course inner join prereq on course.course_id>prereq.course_id Returns the join of the course and prereq table on the join condition course.course_id > prereq.course_id. If the comparison operator is replaced by '=' operator, we get our basic join also called 'equijoin'","title":"Theta Join"},{"location":"dml/#outer-join","text":"Computes the join and then adds tuples from one relation that does not match tuples in the other relation to the result of the join. Avoids loss of information. Null values are used to fill up the attributes of rows in which the common attribute does not match.","title":"Outer Join"},{"location":"dml/#it-is-of-3-types","text":"","title":"It is of 3 types:"},{"location":"dml/#left-outer-join","text":"Returns all records of the first table (left table) and the records that match in both the tables according to the join condition. select * from course natural left outer join prereq Returns all the rows in which the course_id in course and prereq match, as well as the rows from the left column course which do not match.","title":"Left Outer Join"},{"location":"dml/#right-outer-join","text":"Returns all records of the second table (right table) and the records that match in both the tables according to the join condition. select * from course natural right outer join prereq Returns all the rows in which the course_id in course and prereq match, as well as the rows from the right column prereq which do not match.","title":"Right Outer Join"},{"location":"dml/#full-outer-join","text":"Returns the records from both the tables that match according to the join condition as well as those which do not match. select * from course natural full outer join prereq Returns all the rows in which the course_id in course and prereq match, as well as the rows from both the columns which do not match. NOTE: Those records which do not match according to the join condition have null values in those attributes not common to both the tables.","title":"Full Outer Join"},{"location":"psycopg/","text":"Home Connecting with Python Out of the many python packages used to work with Postgresql database server, we will be using psycopg2 package. Installing psycopg2 pip command to install psycopg2 Works on different operating systems including Windows, MacOS, Linux, and Unix pip install psycopg2 Installing specific version: pip install psycopg2=2.8.6 Accessing PostgresSQL from Python using Psycopg Creating Connection: Importing the package import psycopg2 This imports the python package psycopg2. psycopg2.connect(database=\"mydb\", user=\"myuser\", password=\"mypass\" host=\"127.0.0.1\", port=\"5432\") It is a module API that opens a connection to the PostgreSQL database. If successfully opened, it returns a connection object. Thus, the connection command should be included in the try-except block in order to handle the error if the connection is not successfully opened. After doing the required work, connection should be closed finally. So we need to close the exception in the finally block. Below is the code for openning and closing a basic connection object. import psycopg2 def connectDb(dbname, usrname, pwd, address, portnum): conn = None try: # connect to the PostgreSQL database conn = psycopg2.connect(database = dbname, user = usrname, \\ password = pwd, host = address, port = portnum) print (\"Database connected successfully\") except (Exception, psycopg2.DatabaseError) as error: print(error) finally: conn.close() # close the connection connectDb(\"mydb\", \"myuser\", \"mypass\", \"127.0.0.1\", \"5432\") # function call OUTPUT: Database Connected Successfully Creating a cursor connection.cursor() This routine creates a cursor which will be used throughout the program. cursor.close() This method closes the cursor. Executing the query using cursor cursor.execute(sql [, optional parameters]) This routine executes an SQL statement. The SQL statement may be parameterized (i.e., placeholders instead of SQL literals). The psycopg2 module supports placeholder using %s sign. For example: cursor.execute(\"insert into people values (%s,%s)\", (who, age)) cursor.executemany(sql, seq of parameters) This routine executes an SQL command against all parameter sequences or mappings found in the sequence SQL. cursor.callproc(procname[, parameters]) This routine executes a stored database procedure with the given name. The sequence of parameters must contain one entry for each argument that the procedure expects. cursor.rowcount This is a read-only attribute which returns the total number of database rows that have been modified, inserted, or deleted by the last execute() . Fetching the results of the query cursor.fetchone() This method fetches the next row of a query result set, returning a single sequence, or None when no more data is available. cursor.fetchmany([size=cursor.arraysize]) This routine fetches the next set of rows of a query result, returning a list. An empty list is returned when no more rows are available. The method tries to fetch as many rows as indicated by the size parameter. cursor.fetchall() This routine fetches all (remaining) rows of a query result, returning a list. An empty list is returned when no rows are available. Commit to make changed persistent/Rollback to reverse connection.commit() This method commits the current transaction. If you do not call this method, anything you did since the last call to commit() is not visible to other database connections. connection.rollback() This method rolls back any changes to the database since the last call to commit() . import psycopg2 def createTable(): conn = None try: conn = psycopg2.connect(database = \"mydb\", user = \"myuser\", \\ password = \"mypass\", host = \"127.0.0.1\", port = \"5432\") # connect to the database cur = conn.cursor() # create a new cursor cur.execute('''CREATE TABLE EMPLOYEE \\ (emp_num INT PRIMARY KEY NOT NULL, \\ emp_name VARCHAR(40) NOT NULL, \\ department VARCHAR(40) NOT NULL)''') # execute the CREATE TABLE statement conn.commit() # commit the changes to the database print (\"Table created successfully\") cur.close() # close the cursor except (Exception, psycopg2.DatabaseError) as error: print(error) finally: if conn is not None: conn.close() # close the connection createTable() #function call OUTPUT: If the employee table already exists: relation \"employee\" already exists. If the employee tables does not already exist: Table created successfully INSERT QUERY EXECUTION USING PYTHON: import psycopg2 def insertRecord(num, name, dept): conn = None try: # connect to the PostgreSQL database conn = psycopg2.connect(database = \"mydb\", user = \"myuser\", \\ password = \"mypass\", host = \"127.0.0.1\", port = \"5432\") cur = conn.cursor() # create a new cursor # execute the INSERT statement cur.execute(\"INSERT INTO EMPLOYEE (emp_num, emp_name, department) \\ VALUES (%s, %s, %s)\", (num, name, dept)) conn.commit() # commit the changes to the database print (\"Total number of rows inserted :\", cur.rowcount); cur.close() # close the cursor except (Exception, psycopg2.DatabaseError) as error: print(error) finally: if conn is not None: conn.close() # close the connection insertRecord(110, 'Bhaskar', 'HR') #function call OUTPUT: If a row already exists with emp_num=110: duplicate key value violates unique constraint \"employee_pkey\" DETAIL: Key (emp_num)=(110) already exists. If a row with emp_num=110 does not already exist: Total nnumber of rows inserted : 1 DELETE QUERY EXECUTION USING PYTHON: import psycopg2 def deleteRecord(num): conn = None try: # connect to the PostgreSQL database conn = psycopg2.connect(database = \"mydb\", user = \"myuser\", \\ password = \"mypass\", host = \"127.0.0.1\", port = \"5432\") cur = conn.cursor() # create a new cursor # execute the DELETE statement cur.execute(\"DELETE FROM EMPLOYEE WHERE emp_num = %s\", (num,)) conn.commit() # commit the changes to the database print (\"Total number of rows deleted :\", cur.rowcount) cur.close() # close the cursor except (Exception, psycopg2.DatabaseError) as error: print(error) finally: conn.close() # close the connection deleteRecord(110) #function call OUTPUT: If a row does not already exist: Total number of rows deleted : 0 If a row already exists: Total number of rows deleted : 1 UPDATE QUERY EXECUTION USING PYTHON: import psycopg2 def updateRecord(num, dept): conn = None try: # connect to the PostgreSQL database conn = psycopg2.connect(database = \"mydb\", user = \"myuser\", \\ password = \"mypass\", host = \"127.0.0.1\", port = \"5432\") cur = conn.cursor() # create a new cursor # execute the UPDATE statement cur.execute(\"UPDATE EMPLOYEE set department = %s where emp_num = \\ %s\", (dept, num)) conn.commit() # commit the changes to the database print (\"Total number of rows updated :\", cur.rowcount) cur.close() # close the cursor except (Exception, psycopg2.DatabaseError) as error: print(error) finally: conn.close() # close the connection updateRecord(110, \"Finance\") #function call OUTPUT: If a row does not already exist: Total number of rows updated : 0 If a row already exists: Total number of rows updated : 1 SELECT QUERY EXECUTION USING PYTHON: import psycopg2 def selectAll(): conn = None try: # connect to the PostgreSQL database conn = psycopg2.connect(database = \"mydb\", user = \"myuser\", \\ password = \"mypass\", host = \"127.0.0.1\", port = \"5432\") cur = conn.cursor() # create a new cursor # execute the SELECT statement cur.execute(\"SELECT emp_num, emp_name, department FROM EMPLOYEE\") rows = cur.fetchall() # fetches all rows of the query result set for row in rows: print (\"Employee ID = \", row[0], \", NAME = \", \\ row[1], \", DEPARTMENT = \", row[2]) cur.close() # close the cursor except (Exception, psycopg2.DatabaseError) as error: print(error) finally: conn.close() # close the connection selectAll() # function call OUTPUT: EMPLOYEE ID = 110, NAME = Bhaskar, DEPARTMENT = HR EMPLOYEE ID = 111, NAME = Ishaan, DEPARTMENT = FINANCE EMPLOYEE ID = 112, NAME = Jairaj, DEPARTMENT = TECHNOLOGY EMPLOYEE ID = 113, NAME = Ananya, DEPARTMENT = TECHNOLOGY","title":"Psycopg"},{"location":"psycopg/#connecting-with-python","text":"Out of the many python packages used to work with Postgresql database server, we will be using psycopg2 package.","title":"Connecting with Python"},{"location":"psycopg/#installing-psycopg2","text":"pip command to install psycopg2 Works on different operating systems including Windows, MacOS, Linux, and Unix pip install psycopg2 Installing specific version: pip install psycopg2=2.8.6","title":"Installing psycopg2"},{"location":"psycopg/#accessing-postgressql-from-python-using-psycopg","text":"","title":"Accessing PostgresSQL from Python using Psycopg"},{"location":"psycopg/#creating-connection","text":"Importing the package import psycopg2 This imports the python package psycopg2. psycopg2.connect(database=\"mydb\", user=\"myuser\", password=\"mypass\" host=\"127.0.0.1\", port=\"5432\") It is a module API that opens a connection to the PostgreSQL database. If successfully opened, it returns a connection object. Thus, the connection command should be included in the try-except block in order to handle the error if the connection is not successfully opened. After doing the required work, connection should be closed finally. So we need to close the exception in the finally block. Below is the code for openning and closing a basic connection object. import psycopg2 def connectDb(dbname, usrname, pwd, address, portnum): conn = None try: # connect to the PostgreSQL database conn = psycopg2.connect(database = dbname, user = usrname, \\ password = pwd, host = address, port = portnum) print (\"Database connected successfully\") except (Exception, psycopg2.DatabaseError) as error: print(error) finally: conn.close() # close the connection connectDb(\"mydb\", \"myuser\", \"mypass\", \"127.0.0.1\", \"5432\") # function call OUTPUT: Database Connected Successfully","title":"Creating Connection:"},{"location":"psycopg/#creating-a-cursor","text":"connection.cursor() This routine creates a cursor which will be used throughout the program. cursor.close() This method closes the cursor.","title":"Creating a cursor"},{"location":"psycopg/#executing-the-query-using-cursor","text":"cursor.execute(sql [, optional parameters]) This routine executes an SQL statement. The SQL statement may be parameterized (i.e., placeholders instead of SQL literals). The psycopg2 module supports placeholder using %s sign. For example: cursor.execute(\"insert into people values (%s,%s)\", (who, age)) cursor.executemany(sql, seq of parameters) This routine executes an SQL command against all parameter sequences or mappings found in the sequence SQL. cursor.callproc(procname[, parameters]) This routine executes a stored database procedure with the given name. The sequence of parameters must contain one entry for each argument that the procedure expects. cursor.rowcount This is a read-only attribute which returns the total number of database rows that have been modified, inserted, or deleted by the last execute() .","title":"Executing the query using cursor"},{"location":"psycopg/#fetching-the-results-of-the-query","text":"cursor.fetchone() This method fetches the next row of a query result set, returning a single sequence, or None when no more data is available. cursor.fetchmany([size=cursor.arraysize]) This routine fetches the next set of rows of a query result, returning a list. An empty list is returned when no more rows are available. The method tries to fetch as many rows as indicated by the size parameter. cursor.fetchall() This routine fetches all (remaining) rows of a query result, returning a list. An empty list is returned when no rows are available.","title":"Fetching the results of the query"},{"location":"psycopg/#commit-to-make-changed-persistentrollback-to-reverse","text":"connection.commit() This method commits the current transaction. If you do not call this method, anything you did since the last call to commit() is not visible to other database connections. connection.rollback() This method rolls back any changes to the database since the last call to commit() . import psycopg2 def createTable(): conn = None try: conn = psycopg2.connect(database = \"mydb\", user = \"myuser\", \\ password = \"mypass\", host = \"127.0.0.1\", port = \"5432\") # connect to the database cur = conn.cursor() # create a new cursor cur.execute('''CREATE TABLE EMPLOYEE \\ (emp_num INT PRIMARY KEY NOT NULL, \\ emp_name VARCHAR(40) NOT NULL, \\ department VARCHAR(40) NOT NULL)''') # execute the CREATE TABLE statement conn.commit() # commit the changes to the database print (\"Table created successfully\") cur.close() # close the cursor except (Exception, psycopg2.DatabaseError) as error: print(error) finally: if conn is not None: conn.close() # close the connection createTable() #function call OUTPUT: If the employee table already exists: relation \"employee\" already exists. If the employee tables does not already exist: Table created successfully","title":"Commit to make changed persistent/Rollback to reverse"},{"location":"psycopg/#insert-query-execution-using-python","text":"import psycopg2 def insertRecord(num, name, dept): conn = None try: # connect to the PostgreSQL database conn = psycopg2.connect(database = \"mydb\", user = \"myuser\", \\ password = \"mypass\", host = \"127.0.0.1\", port = \"5432\") cur = conn.cursor() # create a new cursor # execute the INSERT statement cur.execute(\"INSERT INTO EMPLOYEE (emp_num, emp_name, department) \\ VALUES (%s, %s, %s)\", (num, name, dept)) conn.commit() # commit the changes to the database print (\"Total number of rows inserted :\", cur.rowcount); cur.close() # close the cursor except (Exception, psycopg2.DatabaseError) as error: print(error) finally: if conn is not None: conn.close() # close the connection insertRecord(110, 'Bhaskar', 'HR') #function call OUTPUT: If a row already exists with emp_num=110: duplicate key value violates unique constraint \"employee_pkey\" DETAIL: Key (emp_num)=(110) already exists. If a row with emp_num=110 does not already exist: Total nnumber of rows inserted : 1","title":"INSERT QUERY EXECUTION USING PYTHON:"},{"location":"psycopg/#delete-query-execution-using-python","text":"import psycopg2 def deleteRecord(num): conn = None try: # connect to the PostgreSQL database conn = psycopg2.connect(database = \"mydb\", user = \"myuser\", \\ password = \"mypass\", host = \"127.0.0.1\", port = \"5432\") cur = conn.cursor() # create a new cursor # execute the DELETE statement cur.execute(\"DELETE FROM EMPLOYEE WHERE emp_num = %s\", (num,)) conn.commit() # commit the changes to the database print (\"Total number of rows deleted :\", cur.rowcount) cur.close() # close the cursor except (Exception, psycopg2.DatabaseError) as error: print(error) finally: conn.close() # close the connection deleteRecord(110) #function call OUTPUT: If a row does not already exist: Total number of rows deleted : 0 If a row already exists: Total number of rows deleted : 1","title":"DELETE QUERY EXECUTION USING PYTHON:"},{"location":"psycopg/#update-query-execution-using-python","text":"import psycopg2 def updateRecord(num, dept): conn = None try: # connect to the PostgreSQL database conn = psycopg2.connect(database = \"mydb\", user = \"myuser\", \\ password = \"mypass\", host = \"127.0.0.1\", port = \"5432\") cur = conn.cursor() # create a new cursor # execute the UPDATE statement cur.execute(\"UPDATE EMPLOYEE set department = %s where emp_num = \\ %s\", (dept, num)) conn.commit() # commit the changes to the database print (\"Total number of rows updated :\", cur.rowcount) cur.close() # close the cursor except (Exception, psycopg2.DatabaseError) as error: print(error) finally: conn.close() # close the connection updateRecord(110, \"Finance\") #function call OUTPUT: If a row does not already exist: Total number of rows updated : 0 If a row already exists: Total number of rows updated : 1","title":"UPDATE QUERY EXECUTION USING PYTHON:"},{"location":"psycopg/#select-query-execution-using-python","text":"import psycopg2 def selectAll(): conn = None try: # connect to the PostgreSQL database conn = psycopg2.connect(database = \"mydb\", user = \"myuser\", \\ password = \"mypass\", host = \"127.0.0.1\", port = \"5432\") cur = conn.cursor() # create a new cursor # execute the SELECT statement cur.execute(\"SELECT emp_num, emp_name, department FROM EMPLOYEE\") rows = cur.fetchall() # fetches all rows of the query result set for row in rows: print (\"Employee ID = \", row[0], \", NAME = \", \\ row[1], \", DEPARTMENT = \", row[2]) cur.close() # close the cursor except (Exception, psycopg2.DatabaseError) as error: print(error) finally: conn.close() # close the connection selectAll() # function call OUTPUT: EMPLOYEE ID = 110, NAME = Bhaskar, DEPARTMENT = HR EMPLOYEE ID = 111, NAME = Ishaan, DEPARTMENT = FINANCE EMPLOYEE ID = 112, NAME = Jairaj, DEPARTMENT = TECHNOLOGY EMPLOYEE ID = 113, NAME = Ananya, DEPARTMENT = TECHNOLOGY","title":"SELECT QUERY EXECUTION USING PYTHON:"},{"location":"tcl/","text":"Home Transaction Control Language Transaction Logical Unit of Work Begins implicitly Ended by commit work or rollback work . Implicit commit can be turned off by a database directive \u2212 For example in JDBC, connection.setAutoCommit(false) ; ACID A-Atomicity C-Consistency I-Isolation D-Durability Transaction Commands in SQL: COMMIT To save all the transactions to the database since the last COMMIT or ROLLBACK command. DELETE FROM instructor WHERE salary = 1000000; COMMIT; The above command deletes all the tuples from the instructor table where the salary is 1000000. After deletion, the result is saved using commit . It ensures durability in a database. Postgresql autocommits all the transactions and thus there is an implicit commit in every command. Thus, even without writing commit, the transaction will be commmitted. ROLLBACK To undo transactions that have not already been saved to the database. * To undo transactions since the last COMMIT or ROLLBACK command was issued. DELETE FROM instructor WHERE id = '4034'; ROLLBACK; The above command first deletes the tuple corresponding to the id '4034' in instructor. But before commiting, a rollback is encountered due to which the delete is reversed and nothing is deleted from the instructor table. SAVEPOINT A point used to roll the transaction back to a certain point without rolling back the entire transaction. Syntax for creating a savepoint: SAVEPOINT <SAVEPOINT NAME>; Syntax for rolling the transaction back to a savepoint: ROLLBACK TO <SAVEPOINT NAME>; BEGIN; SAVEPOINT SP1; DELETE FROM instructor WHERE id = '4034'; SAVEPOINT SP2; DELETE FROM instructor WHERE id = '50885'; SAVEPOINT SP3; ROLLBACK TO SP2; BEGIN keyword is required to begin the transaction. 3 different Savepoints have been created - namely SP1, SP2 and SP3. The transaction rolls back to SP2 in the end which means that the tuple corresponding to the id '4034' has been deleted but the delere corresponding to the id '50885' has been rolled back since the savepoint is before that delete. Thus the resulting relation contains the id '50885' and lacks the id '4034'. Syntax for deleting a savepoint: RELEASE SAVEPOINT <SAVEPOINT NAME>; Can no longer use the ROLLBACK command to undo transactions performed since the last SAVEPOINT. Example: Release savepoint SP1; The savepoint named SP1 created above has been deleted. SET TRANSACTION Can be used to initiate a database transaction. * To specify characteristics for the transaction that follows. SYNTAX: SET TRANSACTION [ READ WRITE | READ ONLY ]; The transaction is read only or read write.","title":"Tcl"},{"location":"tcl/#transaction-control-language","text":"","title":"Transaction Control Language"},{"location":"tcl/#transaction","text":"Logical Unit of Work Begins implicitly Ended by commit work or rollback work . Implicit commit can be turned off by a database directive \u2212 For example in JDBC, connection.setAutoCommit(false) ;","title":"Transaction"},{"location":"tcl/#acid","text":"A-Atomicity C-Consistency I-Isolation D-Durability","title":"ACID"},{"location":"tcl/#transaction-commands-in-sql","text":"","title":"Transaction Commands in SQL:"},{"location":"tcl/#commit","text":"To save all the transactions to the database since the last COMMIT or ROLLBACK command. DELETE FROM instructor WHERE salary = 1000000; COMMIT; The above command deletes all the tuples from the instructor table where the salary is 1000000. After deletion, the result is saved using commit . It ensures durability in a database. Postgresql autocommits all the transactions and thus there is an implicit commit in every command. Thus, even without writing commit, the transaction will be commmitted.","title":"COMMIT"},{"location":"tcl/#rollback","text":"To undo transactions that have not already been saved to the database. * To undo transactions since the last COMMIT or ROLLBACK command was issued. DELETE FROM instructor WHERE id = '4034'; ROLLBACK; The above command first deletes the tuple corresponding to the id '4034' in instructor. But before commiting, a rollback is encountered due to which the delete is reversed and nothing is deleted from the instructor table.","title":"ROLLBACK"},{"location":"tcl/#savepoint","text":"A point used to roll the transaction back to a certain point without rolling back the entire transaction. Syntax for creating a savepoint: SAVEPOINT <SAVEPOINT NAME>; Syntax for rolling the transaction back to a savepoint: ROLLBACK TO <SAVEPOINT NAME>; BEGIN; SAVEPOINT SP1; DELETE FROM instructor WHERE id = '4034'; SAVEPOINT SP2; DELETE FROM instructor WHERE id = '50885'; SAVEPOINT SP3; ROLLBACK TO SP2; BEGIN keyword is required to begin the transaction. 3 different Savepoints have been created - namely SP1, SP2 and SP3. The transaction rolls back to SP2 in the end which means that the tuple corresponding to the id '4034' has been deleted but the delere corresponding to the id '50885' has been rolled back since the savepoint is before that delete. Thus the resulting relation contains the id '50885' and lacks the id '4034'. Syntax for deleting a savepoint: RELEASE SAVEPOINT <SAVEPOINT NAME>; Can no longer use the ROLLBACK command to undo transactions performed since the last SAVEPOINT. Example: Release savepoint SP1; The savepoint named SP1 created above has been deleted.","title":"SAVEPOINT"},{"location":"tcl/#set-transaction","text":"Can be used to initiate a database transaction. * To specify characteristics for the transaction that follows. SYNTAX: SET TRANSACTION [ READ WRITE | READ ONLY ]; The transaction is read only or read write.","title":"SET TRANSACTION"}]}